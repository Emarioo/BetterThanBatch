@TEST_CASE(access)
struct Base {
    mem: i32;
    fn hey() -> i32 {
        return mem; // abreviated access of this.mem
    }
    fn incr() {
        mem = 1 + hey(); // abreviated access of this.hey()
    }
}
base: Base;
*cast<i32*>&base.mem
// Bug 0: Parsing issues, this happens: *& ( (cast<i32*>base) .mem )
//   the member access should happen first though.
base.incr();

struct A {
    n: i32;
}
a: A
p: i32* = &a.n;
*p = 23
_test 23; a.n;

// not implemented yet
// @TEST_CASE(shortcuts)

// struct Base {
//     mem: i32;
// }
// base := Base{}
// base = Base{2}

// base2: Base = .{3}
// base2 = .{7}

@TEST_CASE(slice_method)

fn sl() -> char[] { return "ok" }
_test 2; sl().len // generator missed a push/pop at one point

@TEST_CASE(assign_add)

struct Box {
    head: i32;
}

box: Box
p := &box

p.head += 5 // x64_gen crashed, X64_REG_INVALID appeared somehow

@TEST_CASE(array_in_struct)

struct Box {
    items: i32[20]
}
box: Box

// should cause error, box.items evaluates to a slice
// *(box.items + 9 * sizeof i32)

box.items[9] = 3
_test 3; box.items[9]
_test 3; *(box.items.ptr + 9 * sizeof i32)

_test 16; sizeof box.items
_test 80; sizeof box

@TEST_CASE(indexing_slice)

// move test case elsewhere
fn get() -> Slice<i32> { return Slice<i32>{null,5}; }

_test 8; &(get()[2])

@TEST_CASE(methods)

struct A {
    n: i32;
    fn k() -> i32 { 
        return u();
    }
    fn u() -> i32 {
        return n + 2
    }
}
a: A = A{23}
_test 25; a.k()

@TEST_CASE(methods_poly)
struct Poly<T> {
    t: u32;

    fn first() -> i32 {
        return second();
    }
    fn second() -> i32 {
        #import "Logger"
        log("second, size",sizeof T)
        sizeof T;
        return 0;
    }
}

a: Poly<i32>;
b: Poly<i64>;

a.first();
b.first();