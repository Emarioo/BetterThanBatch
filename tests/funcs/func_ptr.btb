@TEST_CASE(function_pointer)

fn @stdcall okay(a: i32, b: i32) -> i32 {
    return a + b + 5
}

f := okay

_test 27; asm<i32>(f) {
    pop rbx
    mov ecx, 19
    mov edx, 3
    call rbx
    push rax
}

_test 12; f(4, 3)

fn hi(a: i32, b: i32) -> i32 {
    return a + b + 5
}
h := hi

_test 12; h(4, 3)

struct mo {
    x: f32   
}
struct poe<T> {
    x: T 
}

var3: fn (i32, mo[]) -> (i32, i32)
var4: fn (i32, poe<i64>*, mo[]) -> (i32, i32)


fun: fn @unixcall (Slice<i32>) -> void*

@TEST_CASE(func_ptr_callback)

fn map(arr: i32[], callback: fn(i32,i32)) {
    for arr {
        callback(nr, it)
    }
}

list: i32[16] {
    3,5,7,8,23,5,87,9,3,6,8 // 164 = 3+5+7+8+23+5+87+9+3+6+8
}

global sum: i32;

fn act(i: i32, x: i32) {
    sum += x
}

map(list,act)

_test 164; sum


fn @oscall okay() { }
fn call(f: fn@oscall()) { // At one point, the convention of function pointer types was ignored or forgotten.
    f()   
}
call(okay)


fn dub() -> i32, i32 {
    return 5, 9
}
var3: fn () -> (i32, i32) = dub // At one point, the function pointer type's return values wasn't evaluated properly
// var3 := dub    <- this would work fine

a, b : i32 = var3() // Return values where swapped
_test 5; a
_test 9; b