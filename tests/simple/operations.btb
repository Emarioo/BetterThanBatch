@TEST-CASE arithmetic
test 3; 1+2;
test 3; 1- -2;
test -1; 2-3;
test 6; -2*-3;
test 0; 2/3;
test 499; cast<i32>((0.5 % 0.15)*10000);

test 1; 1.2 < 1.3;
test 0; 1.3004 < 1.3;
test 1; -4.0 <= -2.;
test 1; 9.09 <= 9.09;
test 0; -9.0 > 1.3;
test 1; 0.1 > -0.001;
test 1; 99999.0 >= 99998.99999999;
test 1; 99999.0 >= -2.0;
test 0; -4.0 >= -2.;
test 1; 1.0000009 == 1.0000009;
test 0; 1.0000009 == -1.0;
test 1; 3.2 != 4.02;
test 0; 3.2 != 3.2;

fn @intrinsic round(v: f32) -> f32;
fn @intrinsic sqrt(v: f32) -> f32;

test 3; cast<i32>round(3.3);
test 4; cast<i32>round(3.7);
test 1; cast<i32>sqrt(1);
test 1; cast<i32>sqrt(2);
test 2; cast<i32>sqrt(3.9999999);

@TEST-CASE many-math-ops
// The test below is a little scuffed because of issues with precision.
// Python evaluates the math to this: -2159226 while this compiler gives this result: -2158333.
test -2158333; cast<i32>(100000*(5. / 6. - 7. )* 7. / 8. * 4. + (1. / 4. / (1. - 5. + 1. - 4. * 7. - 2. * 3. / 2. - (6. / 3. )/ 2. + (6. / 6. + 8. - 7. )+ 5. )));
test 69; 8+1*(5-8%6+4*3%1%7-4-7+7+(8+7))*4+5%(6/2+(6+8/4*1*5*2*6));