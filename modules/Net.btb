/*
    Networking with server and client


    TODO: It would be convenient if Server and Client was one struct.
      A game that can be a client or server could call the same functions on one struct without
      having to switch between calling server.send and client.send depending whether the game started
      as a server or client.
      The reason this is troublesome is because when a server sends a message, we have to specify which connection
      while the client only has one connection. So we kind of need a switch even if we have one struct.
*/

#import "Array"
#import "Memory"
#import "String"
#import "Threads"
#import "Sockets"

#if OS_WINDOWS
    #import "Windows"
#elif OS_LINUX
    #import "Linux"
#endif

enum EventType {
	EVENT_START,
	EVENT_CLOSE,
	EVENT_RECEIVE, // recived data
	EVENT_CONNECT, // server only
	EVENT_DISCONNECT, // server only
}
struct Event {
	type: EventType;
	who: ConnectionID; // only server
	bytes: char[]; // only on receive
}
enum NetError {
    NET_SUCCESS,
    NET_FAILURE, // general failure
    NET_BAD_IP,
    NET_SOCKET_API_ERROR,
}
enum NetProtocol {
    NET_NONE = 0,
    
    NET_TCP = 0x0,
    NET_UDP = 0x1, // not implemented

    // Protocols and behaviour relevant to the networking library. They have nothing to do with tcp/ip.
    NET_PROTO_STREAM  = 0x0, // library lets you handle the logic for separating messages, use this when implementing HTTP or other protocols
    NET_PROTO_MESSAGE = 0x1, // library sends distinct messages that are length prefixed, use this when implementing multiplayer for a game
}
#macro ConnectionID i32
#macro EventCallback fn(e: Event, user_data: void*)

struct Connection {
    receiver_thread: Thread;
    message_data: char*;
    message_max: i32;
    socket: Socket;
    server: Server*;
    conn_id: ConnectionID;
}
struct MessageHeader {
    length: i32;
}

struct Server {
    fn cleanup() {
        close() // make sure connection is closed

    }

	fn start(ip: char[], port: u32, protocol: NetProtocol = NET_TCP | NET_PROTO_STREAM) -> NetError {
        m_ip.clear()
        m_ip.append(ip)
        m_port = port
        m_protocol = protocol

        m_socket = create_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)
        if !m_socket.valid() {
            log("socket failed")
            return NET_FAILURE
        }
        
        addr: sockaddr_in
        addr.sin_family = AF_INET
        addr.sin_port = htons(m_port)
        addr.sin_addr = htonl(0x7F_00_00_01) // 127.0.0.1
        
        err := m_socket.bind(cast<sockaddr*>&addr, sizeof addr)
        if err != SOCKET_SUCCESS {
            log("bind failed")
            return NET_BAD_IP
        }
        
        err = m_socket.listen(SOMAXCONN) // TODO: Option to specify connection limit
        if err != SOCKET_SUCCESS {
            log("listen failed")
            return NET_FAILURE
        }

        m_is_active = true

        m_listener_thread = ThreadCreate(listener_func, this)
        fn @oscall listener_func(arg: void*) -> i32 {
            server: Server* = arg

            if server.m_event_callback {
                e: Event
                e.type = EVENT_START
                e.who = 0
                server.m_event_callback(e, server.m_user_data)
            }

            while {
                log("#waiting")
                client_socket := server.m_socket.accept(null, null)
                if !client_socket.valid() {
                    log("accept failed")
                    return 0
                }

                connection: Connection* = Allocate(sizeof Connection)
                memzero(connection, sizeof Connection)
                connection.socket = client_socket
                connection.message_max = 0x10000
                connection.message_data = Allocate(connection.message_max)
                connection.receiver_thread = ThreadCreate(receiver_func2, connection)
                connection.server = server
                connection.conn_id = server.m_connections.size()

                server.m_connections.add(connection)

                fn @oscall receiver_func2(arg: void*) -> i32 {
                    connection: Connection* = arg
                    server := connection.server
                    protocol: NetProtocol = connection.server.m_protocol

                    if server.m_event_callback {
                        e: Event
                        e.type = EVENT_CONNECT
                        e.who = connection.conn_id
                        server.m_event_callback(e, server.m_user_data)
                    }

                    while {
                        bytes: i32
                        if protocol & NET_PROTO_MESSAGE {
                            header: MessageHeader

                            bytes = connection.socket.recv(cast<void*>&header, sizeof header, 0)

                            if bytes == 0 {
                                break // graceful shutdown
                            }
                            if bytes < 0 {
                                if server.m_event_callback {
                                    e: Event
                                    e.type = EVENT_DISCONNECT
                                    e.who = connection.conn_id
                                    server.m_event_callback(e, connection.server.m_user_data)
                                }

                                if connection.socket.valid()
                                    connection.socket.close()

                                #if OS_WINDOWS
                                    err := WSAGetLastError()
                                    if err == WSAECONNRESET
                                        break
                                #endif

                                log("recv failed")
                                break
                            }
                            server.m_received_bytes += sizeof header
                            if bytes != sizeof header {
                                log("recv should have read 4 bytes for message length but instead read ", bytes)
                                break
                            }

                            if header.length > 0x1000000 { // more than 1 MB
                                log("recv read ",header.length," as header length which is suspiciously large, was something corrupted?")
                                break
                            }

                            if connection.message_max < header.length {
                                new_max := connection.message_max * 1.5 + header.length + 16
                                new_data := Reallocate(new_max, connection.message_data)
                                // Assert(new_data)
                                connection.message_data = new_data
                                connection.message_max = new_max
                            }
                            total_bytes := 0
                            while total_bytes != header.length {
                                bytes = connection.socket.recv(connection.message_data + total_bytes, header.length - total_bytes, 0)
                                if bytes <= 0
                                    break
                                total_bytes += bytes
                                server.m_received_bytes += bytes
                            }
                        } else {
                            bytes = connection.socket.recv(connection.message_data, connection.message_max, 0)

                            if bytes > 0
                                server.m_received_bytes += bytes
                        }
                        
                        // handle error or shutdown
                        if bytes == 0 {
                            break
                        } else if bytes < 0 {
                            if server.m_event_callback {
                                e: Event
                                e.type = EVENT_DISCONNECT
                                e.who = connection.conn_id
                                server.m_event_callback(e, connection.server.m_user_data)
                            }
                            if connection.socket.valid()
                                connection.socket.close()
                            
                            #if OS_WINDOWS
                                err := WSAGetLastError()
                                if err == WSAECONNRESET
                                    break
                            #endif

                            log("recv failed")
                            break
                        }


                        if connection.server.m_event_callback {
                            e: Event
                            e.type = EVENT_RECEIVE
                            e.who = connection.conn_id
                            e.bytes = Slice<char>{connection.message_data,bytes}
                            server.m_event_callback(e, server.m_user_data)
                        }
                        // std_prints("[READ ", bytes,"]")
                        // std_print(buffer.ptr, bytes)
                    }
                    return 0
                }
            }
            server.m_socket.close()
            return 0
        }

        return NET_SUCCESS
    }
	fn close() {
        // Close listener socket and thread
        if m_socket.valid() {
            m_socket.close()
            if m_listener_thread.valid() {
                ThreadJoin(m_listener_thread)
                m_listener_thread.cleanup();
            }
        }

        // Close other connections
        for m_connections.sliced() {
            if it.socket.valid() {
                it.socket.close()
                ThreadJoin(it.receiver_thread)
                Free(it.message_data)
                Free(it)
            }
        }
        m_connections.cleanup()

        m_is_active = false
    }
    fn wait() {
        if m_listener_thread.valid() {
            ThreadJoin(m_listener_thread)
            m_listener_thread.cleanup()
        }
    }
    fn is_active() -> bool {
        return m_socket.valid()
    }
	fn disconnect(connection_id: ConnectionID) -> NetError {

    }
    // -1 as connection id to send to all connections
	fn send(bytes: char[], connection_id: ConnectionID = -1) -> NetError {
        if connection_id == -1 {
            for connection: m_connections.sliced() {
                send(bytes, connection.conn_id)
            }
            return NET_SUCCESS
        }
        if connection_id >= m_connections.size() {
            return NET_FAILURE
        }
        connection := m_connections.get(connection_id)
    
        if m_protocol & NET_PROTO_MESSAGE {
            header: MessageHeader
            header.length = bytes.len
            err := connection.socket.send(cast<void*>&header, sizeof header, 0)
            if err < 0 {
                log("server send header failed")
                return NET_FAILURE
            }
            m_sent_bytes += sizeof header
            err = connection.socket.send(bytes.ptr, bytes.len, 0)
            if err < 0 {
                log("server send body failed")
                return NET_FAILURE
            }
            m_sent_bytes += bytes.len
        } else {
            err := connection.socket.send(bytes.ptr, bytes.len, 0)
            if err < 0 {
                log("server send stream failed")
                return NET_FAILURE
            }
            m_sent_bytes += bytes.len
        }
        return NET_SUCCESS
    }
    fn set_callback(func: EventCallback, user_data: void*) {
        m_event_callback = func
        m_user_data = user_data
    }
	// fn pollEvents(blocking: bool) -> Event[] { }
	
	m_ip: StringBuilder;
	m_port: u32;
    m_protocol: NetProtocol;

    m_is_active: bool;
    m_socket: Socket;
    m_listener_thread: Thread;

	m_connections: Array<Connection*>;

    m_event_callback: EventCallback;
    m_user_data: void*;

    m_received_bytes: i32;
    m_sent_bytes: i32;

	// mutex: Mutex;
}
struct Client {
    fn cleanup() {
        close() // make sure connection is closed

        if m_message_data {
            Free(m_message_data)
            m_message_data = null
            m_message_max = 0
        }
    }

	fn start(ip: char[], port: u32, protocol: NetProtocol = NET_TCP | NET_PROTO_STREAM) -> NetError {
        m_ip.clear()
        m_ip.append(ip)
        m_port = port
        m_protocol = protocol

        m_socket = create_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)
        if !m_socket.valid() {
            log("socket failed")
            return NET_SOCKET_API_ERROR
        }
        // defer closesocket(client)
        
        result: addrinfo*;
        hints: addrinfo
        hints.ai_family = AF_INET
        hints.ai_socktype = SOCK_STREAM
        hints.ai_protocol  = IPPROTO_TCP

        string_port: StringBuilder
        string_port.append(port)
        
        addr_err := getaddrinfo(ip.ptr, string_port.ptr, &hints, &result)
        if addr_err != 0 {
            log("getaddrinfo failed")
            return NET_BAD_IP
        }
        err := m_socket.connect(result.ai_addr, sizeof *result.ai_addr)

        // addr: sockaddr_in
        // addr.sin_family = AF_INET
        // addr.sin_port = htons(8080)
        // addr.sin_addr = htonl(0x7F_00_00_01) // 127.0.0.1
        // err := connect(client, cast<sockaddr*>&addr, sizeof addr)
        
        if err == SOCKET_FAILURE {
            log("connect failed")
            return NET_BAD_IP
        }

        m_message_max = 0x10000 // 10 KB
        m_message_data = Allocate(m_message_max)

        m_receiver_thread = ThreadCreate(receiver_func, this)

        m_is_active = true // at this point, client should be fully up and running

        fn @oscall receiver_func(arg: void*) -> i32 {
            client: Client* = arg

            if client.m_event_callback {
                e: Event
                e.type = EVENT_START
                e.who = 0
                client.m_event_callback(e, client.m_user_data)
            }

            while {
                bytes: i32
                if client.m_protocol & NET_PROTO_MESSAGE {
                    header: MessageHeader

                    bytes = client.m_socket.recv(cast<void*>&header, sizeof header, 0)

                    if bytes == 0 {
                        break // graceful shutdown
                    }
                    if bytes < 0 {
                        if client.m_event_callback {
                            e: Event
                            e.type = EVENT_CLOSE
                            e.who = 0
                            client.m_event_callback(e, client.m_user_data)
                        }

                        if client.m_socket.valid()
                            client.m_socket.close()

                        #if OS_WINDOWS
                            err := WSAGetLastError()
                            if err == WSAECONNRESET
                                break
                        #endif

                        log("recv failed")
                        break
                    }
                    client.m_received_bytes += sizeof header
                    
                    if bytes != sizeof header {
                        log("recv should have read 4 bytes for message length but instead read ", bytes)
                        break
                    }

                    if header.length > 0x1000000 { // more than 1 MB
                        log("recv read ",header.length," as header length which is suspiciously large, was something corrupted?")
                        break
                    }

                    if client.m_message_max < header.length {
                        new_max := client.m_message_max * 1.5 + header.length + 16
                        new_data := Reallocate(new_max, client.m_message_data)
                        // Assert(new_data)
                        client.m_message_data = new_data
                        client.m_message_max = new_max
                    }
                    total_bytes := 0
                    while header.length != total_bytes {
                        bytes = client.m_socket.recv(client.m_message_data + total_bytes, header.length - total_bytes, 0)
                        if bytes <= 0
                            break
                        total_bytes += bytes
                        client.m_received_bytes += bytes
                    }
                } else {
                    bytes = client.m_socket.recv(client.m_message_data, client.m_message_max, 0)
                    if bytes > 0
                        client.m_received_bytes += bytes
                }
                
                // handle error or shutdown
                if bytes == 0 {
                    break
                } else if bytes < 0 {
                    if client.m_event_callback {
                        e: Event
                        e.type = EVENT_CLOSE
                        e.who = 0
                        client.m_event_callback(e, client.m_user_data)
                    }

                    if client.m_socket.valid()
                        client.m_socket.close()
                    
                    #if OS_WINDOWS
                        err := WSAGetLastError()
                        if err == WSAECONNRESET
                            break
                    #endif

                    log("recv failed")
                    break
                }

                if client.m_event_callback {
                    e: Event
                    e.type = EVENT_RECEIVE
                    e.who = 0
                    e.bytes = Slice<char>{client.m_message_data,bytes}
                    client.m_event_callback(e, client.m_user_data)
                }
                // std_prints("[READ ", bytes,"]")
                // std_print(buffer.ptr, bytes)
            }

            client.m_socket.close()

            return 0
        }

        return NET_SUCCESS
    }
	fn close() {
        if m_socket.valid()
            m_socket.close()

        ThreadJoin(m_receiver_thread)
        m_receiver_thread.cleanup()

        m_is_active = false // set last when client is truly closed and ready to be started again
    }
    fn wait() {
        if m_receiver_thread.valid() {
            ThreadJoin(m_receiver_thread)
            m_receiver_thread.cleanup()
        }
    }
    fn is_active() -> bool {
        return m_socket.valid()
    }

	fn send(bytes: char[]) -> NetError {
        if m_protocol & NET_PROTO_MESSAGE {
            header: MessageHeader
            header.length = bytes.len
            err := m_socket.send(cast<void*>&header, sizeof header, 0)
            if err < 0 {
                log("send msg failed1")
                return NET_FAILURE
            }
            m_sent_bytes += sizeof header
            err = m_socket.send(bytes.ptr, bytes.len, 0)
            if err < 0 {
                log("send msg failed2")
                return NET_FAILURE
            }
            m_sent_bytes += bytes.len
        } else {
            err := m_socket.send(bytes.ptr, bytes.len, 0)
            if err < 0 {
                log("send failed")
                return NET_FAILURE
            }
            m_sent_bytes += bytes.len
        }
        return NET_SUCCESS
    }

    fn set_callback(func: EventCallback, user_data: void*) {
        m_event_callback = func
        m_user_data = user_data
    }

    // fn pollEvents(blocking: bool) -> Event[] { }
    
    /*######################
        Members
    #####################*/

	m_ip: StringBuilder;
	m_port: u32;
    m_protocol: NetProtocol;

    m_is_active: bool;
    m_socket: Socket;

    m_receiver_thread: Thread;
    m_event_callback: EventCallback;
    m_user_data: void*;

    m_message_data: char*;
    m_message_max: i32;
    
    m_received_bytes: i32;
    m_sent_bytes: i32;

    /*######################
        Internal functions
    #####################*/
}

/*#######################
    CODE FOR TESTING
######################*/

// #import "Threads"
// #import "Logger"
// #macro DEFAULT_IP 0x01_00_00_7F
// #macro DEFAULT_PORT 4000
// fn TestServerAndClient() {

//     server_thread := ThreadCreate(TestServer, null)

//     client: Client
//     err := client.start(DEFAULT_IP,DEFAULT_PORT)

//     ThreadJoin(server_thread)

//     log("Running")
// }
// fn TestServer() {
//     server: Server
//     err := server.start(DEFAULT_IP,DEFAULT_PORT)

//     // while {
//     //     events := server.pollEvents(true)
//     //     for events {
//     //         if it.type == Start
//     //     }
//     // }
// }