// import allocation functions
#import "Memory"
// #import "Logger"

#macro ARRAY_CLEANUP(ARR) for @ptr ARR.sliced_unsafe() it.cleanup(); ARR.cleanup();

// TODO: Asserts
struct Array<T> {
    ptr: T*;
    max: i32; // allocated elements (not bytes)
    len: i32; // elements in allocation

    fn cleanup(free_stuff: bool = true) {
        // log("clean array ", free_stuff)
        if !free_stuff {
            ptr = null
            len = 0
            max = 0
        } else {
            reserve(0);
        }
    }

    // returns index where element was inserted
    fn add() -> T* {
        if len + 1 > max {
            res := reserve(7 + max * 2);
            // res := reserve(1 + max); // nocheckin, small growth when debugging
            if !res {
                return null;
            }
        }
        construct(&ptr[len])
        ptr_elem := ptr + len * sizeof T;
        len++;
        return ptr_elem;
    }
    fn add(newElement: T) -> T* {
        if len + 1 > max {
            res := reserve(7 + max * 2);
            // res := reserve(1 + max); // nocheckin, small growth when debugging
            if !res {
                return null;
            }
        }
        ptr[len] = newElement;
        ptr_elem := ptr + len * sizeof T;
        len++;
        return ptr_elem;
    }
    // DOES NOT CALL CLEANUP ON ITEMS
    fn clear() {
        for 0..len {
            destruct(&ptr[nr])
        }
        len = 0
    }
    fn data() -> T* { return ptr }
    fn size() -> i32 { return len; }
    fn sliced_unsafe() -> Slice<T> {
        return Slice<T>{ptr, len};
    }
    fn sliced() -> Slice<T> {
        return Slice<T>{ptr, len};
    }
    fn pop() {
        if len > 0 {
            destruct(&ptr[len-1])
            len--
        }
    }
    fn remove(index: i32) {
        if index >= len
            return;
        for index..len-1 {
            ptr[nr] = ptr[nr+1];
        }
        destruct(&ptr[len-1])
        len--;
    }
    fn get(index: i32) -> T {
        if(index >= len)
            return T{}; // TODO: Assert instead
        return ptr[index];
    }
    fn set(index: i32, t: T) {
        if(index >= len)
            return; // TODO: Assert instead
        ptr[index] = t;
    }
    fn last() -> T* {
        if(len == 0)
            return null; // TODO: Assert instead
        return &ptr[len - 1];
    }
    fn get_unsafe(index: i32) -> T* {
        if(index >= len)
            return null;
        return &ptr[index];
    }
    fn set_unsafe(index: i32, t: T*) {
        if(index >= len)
            return;
        ptr[index] = t;
    }
    fn resize(newLen: i32) -> bool {
        // TODO: destruct elements if shrinking
        if newLen > max {
            if !reserve(newLen)
                return false;
        }
        if newLen < len {
            for newLen..len {
                destruct(&ptr[nr])
            }
        }
        len = newLen;
        return true;
    }
    // new memory is zero-initialized (DO NOT CHANGE THIS IN THE FUTURE BECAUSE CODE DEPEND ON THIS)
    fn reserve(newMax: i32) -> bool {
        // log("newMax",newMax)
        // log("size",sizeof T)
        if newMax==0 {
            // log("{",cast<u64>ptr, max, len,"}",newMax);
            if max!=0 {
                // log("oh")
                for 0..len {
                    destruct(&ptr[nr])
                }
                bytes := max * sizeof T
                Free(ptr, bytes);
                memory_tracker.remove(ptr, bytes, typeid T)
                // log("nah")
            }
            ptr = null;
            max = 0;
            len = 0;
            return true;
        }
        // log("what",cast<u64>ptr)
        if !ptr {
            // log("huh")
            // log("Try reserve, sizeof T =",sizeof T)
            bytes := newMax * sizeof T
            ptr = Allocate(bytes);
            memory_tracker.add(ptr, bytes, typeid T)
            memzero(ptr, bytes)
            // log("allocSize",newMax * sizeof T)
            // log("ptr",ptr)
            // Assert(ptr);
            // initialization of elements is done when adding them
            if !ptr
                return false;
            len = 0;
            max = newMax;
            return true;
        } else {
            if newMax < len {
                for newMax..len {
                    destruct(&ptr[nr])
                }
            }

            new_size := newMax * sizeof T;
            old_size := max * sizeof T;
            newPtr: T* = Reallocate(new_size, ptr, old_size);
            memory_tracker.remove(ptr, old_size, typeid T)
            memory_tracker.add(newPtr, new_size, typeid T)
            // Assert(newPtr);
            if !newPtr
                return false;
            if newMax > max
                memzero(newPtr + len * sizeof T, (newMax - max) * sizeof T);
            ptr = newPtr;
            max = newMax;
            if len > newMax {
                len = newMax;
            }
            return true;
        }
        return false;
    }
    // shallow copy
    fn copy() -> Array<T> {
        new_array: Array<T>
        
        new_array.resize(len)
        memcpy(new_array.ptr, ptr, len * sizeof T)

        return new_array
    }
}
// this does not work
operator []<T>(arr: Array<T>, index: i32) -> T {
    return arr.get(index)
}

// Some code to quickly test an array
// #import "Logger"
// #import "Array"
// #import "Lang"

// global counter: i32
// struct Item {
//     x: i32
//     fn init() {
//         x = counter++
//         log("init ",x)
//     }
//     fn cleanup() {
//         log("cleanup ",x)
//     }
// }

// arr: Array<Item>;
// arr.add(Item{4})
// arr.add(Item{23})
// arr.pop()
// arr.add(Item{92})
// arr.add(Item{96})
// arr.add(Item{98})
// for arr.sliced() {
//     log(&it)
// }
// log(arr.len, " ", arr.max)
// arr.reserve(0);


// ######
// MORE CODE FOR TESTING
// ##########


// #import "Logger"
// #import "Array"
// #import "Lang"

// global counter: i32
// struct Item {
//     x: i32
//     fn init() {
//         x = counter++
//         log("init ",x)
//     }
//     fn cleanup() {
//         log("cleanup ",x)
//     }
// }

// // operator cast(x: i32) -> Item { return Item{x} }

// memory_tracker.init()

// arr: Array<Item>;
// arr.add(Item{4})
// arr.add(Item{23})
// arr.pop()
// arr.add(Item{92})
// arr.add(Item{96})
// arr.add(Item{98})
// for arr.sliced() {
//     log(&it)
// }
// log(arr.len, " ", arr.max)

// memory_tracker.print_memory()

// arr.reserve(0);

// memory_tracker.print_memory()