// import allocation functions
#import "Memory"
// #import "Logger"

#macro ARRAY_CLEANUP(ARR) for @ptr ARR.sliced_unsafe() it.cleanup(); ARR.cleanup();

// TODO: Asserts
// Note that memory is uninitialized
struct Array<T> {
    // zero initialized by default
    ptr: T*;
    max: i32; // allocated bytes
    len: i32; // elements in allocation

    fn cleanup(free_stuff: bool = true) {
        if !free_stuff {
            ptr = null
            len = 0
            max = 0
        } else {
            reserve(0);
        }
    }

    // returns index where element was inserted
    // fn add(newElement: T) -> i32 {
    fn add(newElement: T) -> T* {
        if len + 1 > max {
            res: bool = reserve(7 + max * 2);
            // res: bool = reserve(1 + max); // nocheckin, small growth when debugging
            if !res {
                return null;
            }
        }
        ptr[len] = newElement;
        ptr_elem := ptr + len * sizeof T;
        // ind = len;
        len++;
        return ptr_elem;
        // return ind;
    }
    // DOES NOT CALL CLEANUP ON ITEMS
    fn clear() {
        len = 0
    }
    fn data() -> T* { return ptr }
    fn size() -> i32 { return len; }
    fn sliced_unsafe() -> Slice<T> {
        return Slice<T>{ptr, len};
    }
    fn sliced() -> Slice<T> {
        return Slice<T>{ptr, len};
    }
    fn pop() {
        if len > 0
            len--
    }
    fn remove(index: i32) {
        if index >= len
            return;
        for index..len-1 {
            ptr[nr] = ptr[nr+1];
        }
        // TODO: Cleanup?
        ptr[len-1] = T{};
        len--;
    }
    fn get(index: i32) -> T {
        if(index >= len)
            return T{}; // TODO: Assert instead
        return ptr[index];
    }
    fn last() -> T* {
        if(len == 0)
            return null; // TODO: Assert instead
        return &ptr[len - 1];
    }
    fn get_unsafe(index: i32) -> T* {
        if(index >= len)
            return null;
        return ptr + index * sizeof T;
    }
    fn resize(newLen: i32) -> bool {
        if newLen > max {
            if !reserve(newLen)
                return false;
        }
        len = newLen;
        return true;
    }
    // new memory is zero-initialized (DO NOT CHANGE THIS IN THE FUTURE BECAUSE CODE DEPEND ON THIS)
    fn reserve(newMax: i32) -> bool {
        // log("newMax",newMax)
        // log("size",sizeof T)
        if newMax==0 {
            // log("{",cast<u64>ptr, max, len,"}",newMax);
            if max!=0 {
                // log("oh")
                Free(ptr, max * sizeof T);
                // log("nah")
            }
            ptr = null;
            max = 0;
            len = 0;
            return true;
        }
        // log("what",cast<u64>ptr)
        if !ptr {
            // log("huh")
            // log("Try reserve, sizeof T =",sizeof T)
            ptr = Allocate(newMax * sizeof T);
            memzero(ptr, newMax * sizeof T)
            // log("allocSize",newMax * sizeof T)
            // log("ptr",ptr)
            // Assert(ptr);
            // initialization of elements is done when adding them
            if !ptr
                return false;
            len = 0;
            max = newMax;
            return true;
        } else {
            ns := newMax * sizeof T;
            os := max * sizeof T;
            newPtr: T* = Reallocate(ns, ptr, os);
            // Assert(newPtr);
            if !newPtr
                return false;
            if newMax > max
                memzero(newPtr + len * sizeof T, (newMax - max) * sizeof T);
            ptr = newPtr;
            max = newMax;
            if len > newMax {
                len = newMax;
            }
            return true;
        }
        return false;
    }
}
// this does not work
operator []<T>(arr: Array<T>, index: i32) -> T {
    return arr.get(index)
}

// Some code to quickly test an array
// #import "Logger"
// #import "Array"
// arr: Array<i32>;
// arr.add(4)
// arr.add(23)
// arr.pop()
// arr.add(92)
// arr.add(92)
// arr.add(92)
// for arr.sliced() {
//     log(it)
// }
// log(arr.len, arr.max)
// arr._reserve(0);