// import allocation functions
#import "OS"

// TODO: Asserts
struct DynamicArray<T> {
    // zero initialized by default
    ptr: T*;
    max: u32; // allocated bytes
    len: u32; // elements in allocation

    // returns index where element was inserted
    fn add(newElement: T) -> u32 {
        if(len + 1 > max){
            if(!this._reserve(5 + max * 1.5)){
                return -1;
            }
        }
        ptr[len] = newElement;
        return len++;
    }
    fn sliced() -> Slice<T> {
        return Slice<T>{ptr, len};
    }
    fn pop() {
        if len > 0
            len--
    }
    // fn get(index: u32) -> T {
    //     // assert
    //     return ptr[]
    // }
    fn getPtr(index: u32) -> T* {
        if(index >= len)
            return null;
        return ptr + index * sizeof T;
    }
    fn _reserve(newMax: u32) -> bool {
        if(newMax==0){
            if(max!=0){
                // for(u32 i = 0; i < used; i++){
                //     (ptr + i)->~T();
                // }

                Free(ptr, max * sizeof T);
            }
            ptr = null;
            max = 0;
            len = 0;
            return true;
        }
        if(!ptr){
            ptr = Allocate(newMax * sizeof T);
            // Assert(ptr);
            // initialization of elements is done when adding them
            if(!ptr)
                return false;
            max = newMax;
            return true;
        } else {
            // if(newMax < max) {
            //     for(u32 i = newMax; i < used; i++){
            //         (ptr + i)->~T();
            //     }
            // }
            newPtr: T* = Reallocate(ptr, max * sizeof T, newMax * sizeof T);
            // Assert(newPtr);
            if(!newPtr)
                return false;
            ptr = newPtr;
            max = newMax;
            if(len > newMax){
                len = newMax;
            }
            return true;
        }
        return false;
    }
}