// #import "OS"

// always preloaded
// fn @native prints(str: char[]);
// fn @native printc(str: char);

fn @intrinsic strlen(str: char*) -> u32;

// This is not beautifully done. If _print has a bug then printi would work in interpreter but not otherwise. No one likes inconsistencies. 
#ifdef LINK_BYTECODE
fn @native printi(str: i64);
fn @native printd(str: f32);
#else
#define printi(...) _print(...)
#define printd(...) _print(...)
#endif

/*
    The reason functions are named "print" and not "log"
    is because you might want your own log function.
    Altough, log is a smaller name than print so it would be unfortunate
    if the language took that name from you.
*/

#define log(...) { log_inner(...) }
#define log_inner(X, ...) _print(X); _print(' '); log_inner(...)
#define log_inner(X) _print(X); _print('\n')

#define println(...) { print_inner(...) _print("\n"); }
#define print(...) { print_inner(...) }
#define print_inner(X,...) _print(X); print_inner(...)

// IMPORTANT: SAFE_CONVERSIONS in x64_Converter must be defined for this function to work properly.
//  There will be some unexpected bits otherwise.
fn @hide _print(t: i64){
    // If you are worried that this language will be filled with ifdefs like C/C++
    // then you can calm down. This is just temporary.
    #ifdef LINK_BYTECODE
    printi(t)
    #else
    
    // optimise by using a log10 function to know how many characters you need.
    // then allocate some memory for that space
    // run a while looop filling up that memory
    // then print all characters at once
    // free memory
    // One last thing, the memory should be allocated using a linear allocator
    // or some other temporary allocator. Perhaps you can allocate it on the
    // stack or something?
    // log("int")
    if t == 0 {
        printc('0')
        return;
    }
    signed := false;
    if t < 0 {
        signed = true;
        t = 0-t;
    }
    str: char[20];
    used := 19;
    while t > 0 && used > 0 {
        num: u32 = t % 10;
        // log('A','0'+num)
        // log(,num)
        str.ptr[used] = num + '0';
        used--;
        
        t = t / 10;
    }
    str.ptr += used + 1;
    // str.len -= used - 1;
    str.len -= used + 1;
    if signed
        printc('-');
    prints(str);
    #endif
}
// fn @hide _print(t: u64){
//     // If you are worried that this language will be filled with ifdefs like C/C++
//     // then you can calm down. This is just temporary.
//     #ifdef LINK_BYTECODE
//     printi(t)
//     #else
    
//     // optimise by using a log10 function to know how many characters you need.
//     // then allocate some memory for that space
//     // run a while looop filling up that memory
//     // then print all characters at once
//     // free memory
//     // One last thing, the memory should be allocated using a linear allocator
//     // or some other temporary allocator. Perhaps you can allocate it on the
//     // stack or something?
//     if t == 0 {
//         printc('0')
//         return;
//     }
//     signed = false;
//     if t < 0 {
//         signed = true;
//         t = 0-t;
//     }
//     str: char[20];
//     used = 19;
//     while t > 0 && used > 0 {
//         num = t % 10;
//         str.ptr[used] = num + '0';
//         used--;
        
//         t = t / 10;
//     }
//     str.ptr += used + 1;
//     str.len -= used + 1;
//     if signed
//         printc('-');
//     prints(str);
//     #endif
// }
fn _print(str: char*){
    slice = Slice<char>{str, strlen(str)};
    prints(slice);
}
// IMPORTANT: This function does not print accurate
//  floats. It has some precision issues.
fn _print(t: f32){
    // #ifndef X64
    // printd(t)
    // #else
    bits: u32 = *cast<u32*>cast<void*>&t;
    // log("float")
    
    sign = (bits >> 31) & 1u;
    exp = (bits >> 23) & 0xFF
    mantissa: u64 = 0x80_0000 | (bits & 0x7FFFFF)

// 0x8000_0000_0000_0000

    // printBits(bits);
    if sign
        _print('-');
// 01011111000000000000000000000000
    intPart: u64 = 0;
    decimalBits: i32 = 23 - (exp-127);
    // log(decimalBits)
    // _print('\n')
    // _print(exp)
    // _print('\n')
    if decimalBits < 1 {
        // log(mantissa);
        intPart = (mantissa) << (0-decimalBits);
        // log("herea");
        // printBits(intPart);
        if intPart == 0 {
            printc('0')
        } else {
            str: char[23];
            used = 22;
            while intPart > 0u && used > 0 {
                digit: u8 = intPart % 10u;
                // log("i",intPart);
                // log("d",digit);
                str.ptr[used] = digit + '0';
                used--;
                intPart = intPart / 10u;
            }
            str.ptr += used + 1;
            str.len -= used + 1;
            prints(str);
        }
        // _print(intPart);
        _print('.');
        _print('0');
    } else {
        if exp > 126u
            intPart = (mantissa) >> decimalBits;
        _print(cast<i64>intPart);
        _print('.');

        decimals: char[24];

        acc: u64 = 0;
        mul: u64 = 1;
        // _print(decimalBits); _print('\n')
        precision = 19; // digits u64 can contain (18446744073709551615)
        minBits = decimalBits - precision;
        if minBits < 0
            minBits = 0;
        for @rev minBits..decimalBits {
            mul *= 5u;
            acc = acc*10u
            // log("nr", nr)
            if nr < 24 {
                bit = cast<u64>1 & (mantissa >> nr)
                if bit {
                    acc += mul;
                }
                // _print(acc); _print('\n')
            }
        }
        // _print(acc);
        if acc == 0
            _print('0');
        blank = true;
        lastZero = 0
        limit = precision;
        if decimalBits < precision;
            limit = decimalBits;
        for @rev 0..limit {
            digit = acc % 10u;
            acc = acc / 10u;
            if !blank || digit != 0 {
                decimals.ptr[nr] = digit + '0';
                if blank
                    lastZero = nr+1
                blank = false;
            }
        }
        decimals.len = lastZero;
        _print(decimals)
    }

    // fn printBits(bits: u64) {
    //     for @reverse 0..64 {
    //         if bits & (cast<u64>1 << nr) {
    //             print('1')
    //         } else 
    //             print('0')
    //     }
    //     print('\n')
    // }
    // fn printBits(bits: u32) {
    //     for @reverse 0..32 {
    //         if bits & (cast<u64>1 << nr) {
    //             print('1')
    //         } else 
    //             print('0')
    //     }
    //     print('\n')
    // }
    // #endif
}
fn _print(tt: f64){
    // TODO: Print 64-bit float without casting it to 32-bit and loosing information.
    _print(cast<f32>tt);
}
// fn _print(p: void*) {
fn _print<T>(p: T*) {
    // _print(cast<u64>p)
    prints("0x")
    for @rev 0..16 {
        hex := (cast<u64>p >> cast<u64>(4*nr)) & cast<u64>0xF;
        if hex < 10u
            printc('0'+hex)
        else
            printc('a' + hex - 10)
    }
}
fn @hide _print(t: char){
    printc(t);
    // prints(Slice<char>{&t, 1})
}
fn @hide _print(t: bool){
    if t
        prints("true");
    else
        prints("false");
}
fn @hide _print(t: char[]){
    prints(t);
}