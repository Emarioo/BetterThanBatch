// #import "OS"
#import "String"


#macro log(...) { log_inner(...) }
#macro log_inner(X, ...) std_print(X); log_inner(...)
// #macro log_inner(X, ...) std_print(X); std_print(' '); log_inner(...)
#macro log_inner(X) std_print(X); std_print('\n')
#macro log_inner() std_print('\n')

#macro std_prints(X,...) std_print(X); std_prints(...)

fn std_print(value: u64){
    s: StringBuilder
    s.append(value)
    prints(s)
}
fn std_print(value: i64){
    s: StringBuilder
    s.append(value)
    prints(s)
}
fn std_print(str: char*){
    slice := Slice<char>{str, strlen(str)};
    prints(slice);
}
// IMPORTANT: This function does not print accurate
//  floats. It has some precision issues.
// max_decimals can be used to limit the amount of printed decimals, spamming the terminal is bad
fn std_print(value: f32, max_decimals: i32 = 3){
    s: StringBuilder
    s.append(value, max_decimals)
    prints(s)
}
fn std_print(value: f64, max_decimals: i32 = 3){
    s: StringBuilder
    s.append(value, max_decimals)
    prints(s)
}
fn std_print(value: void*) {
    s: StringBuilder
    s.append(value)
    prints(s)
}
fn std_print(t: char){
    // printc(t);
    prints(Slice<char>{&t, 1})
}
fn std_print(t: bool){
    if t
        prints("true");
    else
        prints("false");
}
fn std_print(t: char[]){
    prints(t);
}
fn std_print(ptr: char*, len: u64){
    prints(Slice<char>{ptr, len});
}

fn std_print_hex(ptr: void*, len: u32, big_endian: bool = false) {
    bytes := cast<u8*>cast<void*>ptr

    if big_endian {
        for @rev 0..len {
            if len > 20u && nr % 4 == 3 {
                if nr % 16 != 15
                    std_print(' ')
            }
            if len > 20u && nr % 16 == 15 {
                if nr != len-1
                    std_print('\n')
                std_prints(nr,": ")
            }
            hex0 := bytes[nr] & cast<u8>0x0F
            hex1 := bytes[nr] >> cast<u8>4
            if hex1 < 10u   printc('0' + hex1)
            else            printc('a' + hex1 - 10)
            if hex0 < 10u   printc('0' + hex0)
            else            printc('a' + hex0 - 10)
        }
    } else {
        for 0..len {
            if len > 20u && nr % 16 == 0 {
                if nr != 0
                    std_print('\n')
                std_prints(nr,": ")
            }
            if len > 20u && nr % 4 == 0 {
                if nr % 16 != 0
                    std_print(' ')
            }
            hex0 := bytes[nr] & cast<u8>0x0F
            hex1 := bytes[nr] >> cast<u8>4
            if hex1 < 10u   printc('0' + hex1)
            else            printc('a' + hex1 - 10)
            if hex0 < 10u   printc('0' + hex0)
            else            printc('a' + hex0 - 10)
        }
    }
}

// fn std_print_hex(value: i32) {
//     s: StringBuilder
//     s.append_hex(value)
//     prints(s)
// }
fn std_print_hex(value: u64) {
    s: StringBuilder
    s.append_hex(value)
    prints(s)
}
fn std_print_bits(value: u64) {
    s: StringBuilder
    s.append_bits(value)
    prints(s)
}