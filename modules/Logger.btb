// #import "OS"

fn @native prints(str: char[]);
fn @native printi(str: i64);
fn @native printc(str: char);
fn @native printd(str: f32);

/*
    The reason functions are named "print" and not "log"
    is because you might want your own log function.
    log is a smaller name than print so it would be unfortunate
    if the language took that name from you.
*/

// IMPORTANT: SAFE_CONVERSIONS in x64_Converter must be defined for this function to work properly.
//  There will be some unexpected bits otherwise.
fn @hide _print(t: i64){
    // If you are worried that this language will be filled with ifdefs like C/C++
    // then you can calm down. This is just temporary.
    #ifndef X64
    printi(t)
    #else
    
    // optimise by using a log10 function to know how many characters you need.
    // then allocate some memory for that space
    // run a while looop filling up that memory
    // then print all characters at once
    // free memory
    // One last thing, the memory should be allocated using a linear allocator
    // or some other temporary allocator. Perhaps you can allocate it on the
    // stack or something?
    if t == 0 {
        printc('0')
        return;
    }

    str: char[20];
    used = 19;
    while t > 0 && used > 0 {
        num = t % 10;
        str.ptr[used] = num + '0';
        used--;
        
        t = t / 10;
    }
    str.ptr += used + 1;
    str.len -= used - 1;
    prints(str);
    #endif
}
// IMPORTANT: This function does not print accurate
//  floats. It has some precision issues.
fn @hide _print(t: f32){
    // #ifndef X64
    // printd(t)
    // #else
    bits: u32 = *cast<u32*>cast<void*>&t;

    sign = (bits >> 31) & 1;
    exp = (bits >> 23) & 0xFF
    mantissa = bits & 0x7FFFFF

    mul: u64 = 1;
    acc: u64 = 1;
    precision = 17;
    // decrease precision for large numbers
    if exp >= 128
        precision -= ((exp+1) & 0x7F)>>2
    for i: 0..precision {
        mul *= 5;
        acc *= 10;
        if mantissa & (1 << (22 - i)) {
            acc += mul;
        }
    }

    if exp < 128
        acc = acc >> (127 - exp);
    else
        acc = acc << ((exp+1) & 0x7F);

    arr: char[30];
    index = 30;
    rounds = precision
    while acc != 0 || rounds > 0 {
        rounds--;
        digit = 0;
        if acc != 0 {
            digit = acc % 10;
            acc = acc / 10;
        }
        
        //     printi(index);
        //     printc(' ');
        //     printi(arr.len);
        //     printc(' ');
        //     printi(digit);
        //     printc('\n');
        if(index == arr.len && digit == 0) {
            precision--;
            continue
        }
        arr.ptr[--index] = '0' + digit;
        if index == 30 - precision {
            arr.ptr[--index] = '.';
        }
    }
    if arr.ptr[index] == '.'
        arr.ptr[--index] = '0';
    if sign 
        arr.ptr[--index] = '-';

    arr.ptr += index;
    arr.len -= index;

    prints(arr)

    // fn printBits(bits: u64) {
    //     for @reverse 0..32 {
    //         if bits & (cast<u64>1 << nr) {
    //             print('1')
    //         } else 
    //             print('0')
    //     }
    //     print('\n')
    // }
    // #endif
}
fn @hide _print(t: char){
    prints(Slice<char>{&t, 1})
}
fn @hide _print(t: bool){
    if t
        prints("true");
    else
        prints("false");
}
fn @hide _print(t: char[]){
    prints(t);
}

// macros does not travel across imports yet ):
// Now they do haha!
#define print(X,...) _print(X); print(...);
#define print()
#define println(...) print(...); _print("\n");

#define log(X, ...) _print(X); _print(' '); log(...)
#define log(X) _print(X); _print('\n')
