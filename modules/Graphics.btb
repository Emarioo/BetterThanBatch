/*
    A module for rendering things independent on the platform/operating system.
    
    DISCLAIMER: Currently only works on Windows (I don't have an Apple or Linux computer)
*/

// only OpenGL for now
#import "GLFW"
#import "GLAD"
#import "STB"
// #import "GLEW"

#import "Logger"
#import "Lang"
#import "Array"
#import "Memory"
#import "OS"

/* #####################################################
    GRAPHICS LIBRARY (depends on GLAD, GLFW, OPENGL)
    1. management
##################################################### */

struct WindowContext {
    glfw_window: void*;
    width: i32; // read only
    height: i32;
    running: bool = true;
    delta: f32;
    prev_timestamp: u64;
    
    camera_zoom: f32 = 1.0; // modifiable
    camera_x: f32 = 1.0; // modifiable
    camera_y: f32 = 1.0; // modifiable
    
    base_shader: u32;
    font: Font*;
    fn defaultFont() -> Font* {
        return font
    }
    
    vbo: u32;
    vao: u32;
    ibo: u32;
    
    enable_ui_space: bool = true;
    fn enableUISpace(yes: bool) {
        enable_ui_space = yes
    }
    
    // ## user input events ##
    
    fn getMouseX() -> f32 { return m_mouseX; }
    fn getMouseY() -> f32 { return m_mouseY; }
    // raw input from first person
    // float getRawMouseX() const;
    // float getRawMouseY() const;
    fn setMouseX(x: f32) { m_mouseX=x; }
    fn setMouseY(y: f32) { m_mouseY=y; }
    fn getScrollX() -> f32 {
        return m_tickScrollX;
	}
    fn getScrollY() -> f32 {
        return m_tickScrollY;
    }
    fn setScrollX(x: f32) { m_frameScrollX += x; m_tickScrollX += x;}
    fn setScrollY(y: f32) { m_frameScrollY += y; m_tickScrollY += y; }

    fn setInput(code: i32, down: bool) {
        index: i32 = -1;
		for @ptr inp: m_inputs.sliced() {
			if (inp.code == code) {
				index = nr;
				break;
			}
		}
        input: KeyInput*;
		if index==-1 {
			index = m_inputs.size();
			m_inputs.add(KeyInput{});
            input = m_inputs.get_unsafe(index)
            input.code = code;
		} else {
            input = m_inputs.get_unsafe(index)
        }
		if (down) {
			if (!input.down) {
				// printf("PRESSED %c (%d)\n",(char)code,code);
				// log::out << "PRESSED "<<(char)code << " ("<<code << ")\n";
				input.down = true;
				input.tickPressed++;
				input.framePressed++;
			}
		}else{
			// log::out << "RELEASED "<<(char)code << " ("<<code << ")\n";
			// printf("RELEASED %c (%d)\n",(char)code,code);
			input.down = false;
			input.tickReleased++;
			input.frameReleased++;
		}
    }

    // std::string pollPathDrop();
    // u32 pollChar();
    // void resetPollChar();

    fn isKeyDown(code: i32) -> bool {
        for @ptr inp: m_inputs.sliced_unsafe() {
			if (inp.code == code)
				return inp.down;
		}
		return false;
    }
    fn isKeyPressed(code: i32) -> bool {
        for @ptr inp: m_inputs.sliced_unsafe() {
			if (inp.code == code) {
				// log::out << "IS "<<(char)code<<"\n";
				// if (m_parent->isRenderingWindow()) {
				// 	if (m_inputs[i].framePressed > 0) {
				// 		return true;
				// 	}
				// } else {
					if (inp.tickPressed > 0) {
						// log::out << " Done\n";
						return true;
					}
				// }
				return false;
			}
		}
		return false;
    }
    fn isKeyReleased(code: i32) -> bool {
        for @ptr inp: m_inputs.sliced_unsafe() {
			if (inp.code == code) {
				// if (m_parent->isRenderingWindow()) {
				// 	if (m_inputs[i].frameReleased > 0) {
				// 		return true;
				// 	}
				// }
				// else {
					if (inp.tickReleased > 0) {
						return true;
					}
				// }
				return false;
			}
		}
		return false;
    }
    
    // void enableFirstPerson(bool yes);
    // bool isFirstPerson() const { return m_enabledFirstPerson; }
    
    // std::string pollClipboard();
    // void setClipboard(const std::string& str);

    // // If true, the cursor will be made visible.
    // void setCursorVisible(bool visible);
    // // Whether the cursor is locked to the window.
    // bool isCursorLocked() const { return m_cursorLocked;}
    // // If true, the cursor will be made invisible and locked to the window. Use this when you want the player to lock around.
    // void lockCursor(bool locked);

    fn resetEvents(resetFrameInput: bool) {
        resetFrameInput = false;
        if (resetFrameInput) {
            m_frameScrollX = 0;
            m_frameScrollY = 0;
            // m_frameRawMouseX = 0;
            // m_frameRawMouseY = 0;
            for @ptr inp: m_inputs.sliced_unsafe() {
                inp.framePressed = 0;
                inp.frameReleased = 0;
            }
        } else {
            m_tickScrollX = 0;
            m_tickScrollY = 0;
            // m_tickRawMouseX = 0;
            // m_tickRawMouseY = 0;
            for @ptr inp: m_inputs.sliced_unsafe() {
                if(inp.tickPressed!=0){
                    code := inp.code;
                    // log::out << "RESET "<<(char)code << " ("<<code << ")\n";
                    // printf("RESET %c (%d)\n",(char)code,code);
                }
                inp.tickPressed = 0;
                inp.tickReleased = 0;
            }
        }
    }
    
    m_inputs: Array<KeyInput>;
    m_mouseX: f32 = 0;
    m_mouseY:  f32 = 0;
    m_lastMouseX: f32 = -1;
    m_lastMouseY: f32 = -1;
    // float m_tickRawMouseX = 0, m_tickRawMouseY = 0, m_frameRawMouseX = 0, m_frameRawMouseY = 0;
    m_tickScrollX: f32 =0;
    m_tickScrollY: f32 = 0;
    m_frameScrollX: f32 = 0;
    m_frameScrollY: f32 = 0;
}
struct KeyInput { // also mouse
    code: i32 = 0;
    down: bool = false;
    tickPressed: i8 = 0;
    framePressed: i8 = 0;
    tickReleased: i8 = 0;
    frameReleased: i8 = 0;
};
struct Texture {
    id: u32;
    width: i32;
    height: i32;
    
    // temporary?
    data: u8*;
    data_len: i32;
}
struct Font {
    id: u32;
    width:  i32;
    height: i32;
    
    char_width: i32;
    cell_w: i32;
    cell_h: i32;
    
    // temporary?
    data: u8*;
    data_len: i32;
    
    fn get_uvwh(chr: char) -> f32, f32, f32, f32 {
        return 
            cast<f32> cell_w * (cast<i32> chr % 16) / cast<f32> width,
            cast<f32> cell_h * (cast<i32> chr / 16) / cast<f32> height,
            cast<f32> cell_w * (cast<i32> chr % 16) / cast<f32> width + cast<f32>char_width / width,
            cast<f32> cell_h * (cast<i32> chr / 16) / cast<f32> height + cast<f32>cell_h / height;
    }
    fn width_of_text(text: char[], text_height: f32) -> f32 {
        max_len := 0
        len := 0
        for text {
            if it == '\n' {
                len=0
                continue
            }
            len++
            if len > max_len
                max_len = len
        }
        return max_len * cast<f32> char_width/cast<f32>cell_h * text_height
    }
    fn height_of_text(text: char[], text_height: f32) -> f32 {
        len := 1
        for text {
            if it == '\n'
                len++
        }
        return len * text_height
    }
    fn size_of_text(text: char[], text_height: f32) -> f32, f32 {
        // TODO:
    }
}

fn DestroyWindow(window: WindowContext*) {
    // TODO: Anything else to destroy? glfwTerminate if we only have one window left?
    
    glfwDestroyWindow(window.glfw_window)
    Free(window)
}
fn CreateWindow(width: i32, height: i32, title: char[] = "The beginning of something new") -> WindowContext* {
    yes := glfwInit();
    if !yes {
        log("glfwInit failed");
        return null;
    }
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfw_window := glfwCreateWindow(width, height, title.ptr, null, null);
    if !glfw_window {
        log("window failed");
        glfwTerminate();
        return null
    }

    glfwMakeContextCurrent(glfw_window)

   

    yes = gladLoadGL()
    // yes = gladLoadGLLoader(glfwGetProcAddress)
    if !yes {
        log("gladLoadGL failed")
        glfwTerminate()
        return null;
    }

    glViewport(0, 0, width, height)
    GLCHECK

    glEnable(GL_BLEND)
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
    // glEnable(GL_CULL)

    window: WindowContext* = Allocate(sizeof WindowContext);
    *window = WindowContext{}
    window.glfw_window = glfw_window
    window.width = width
    window.height = height
    
    MapWindowContext(window)
    
    glfwSetKeyCallback(glfw_window, KeyCallback);
    glfwSetMouseButtonCallback(glfw_window, MouseCallback);
    glfwSetCursorPosCallback(glfw_window, CursorPosCallback);
    glfwSetScrollCallback(glfw_window, ScrollCallback);
    
    glfwSetWindowSizeCallback(glfw_window, ResizeCallback);
    // glfwSetWindowFocusCallback(window, FocusCallback);
    // glfwSetWindowCloseCallback(window, CloseCallback);
    // glfwSetWindowPosCallback(window, PosCallback);
    // glfwSetCharCallback(window, CharCallback);
    // glfwSetDropCallback(window, DropCallback);

    
    vshader := @strbeg
        #version 330 core
        layout(location = 0) in vec2 vPos;
        layout(location = 1) in vec2 vUV;
        layout(location = 2) in vec4 vColor;
        layout(location = 3) in float vTexture;

        uniform vec2 uWindow;

        out vec2 fUV;
        out vec4 fColor;
        flat out int fTexture;

        void main() {	
            fUV=vUV;
            fColor=vColor;
            fTexture=int(vTexture);

            gl_Position = vec4((vPos.x)/uWindow.x*2.0-1.0, 1.0-(vPos.y)/uWindow.y*2.0, 0, 1);
            // gl_Position = vec4(vPos.x,vPos.y, 0, 1);
        };
        @strend;
    fshader := @strbeg
        #version 330 core
        layout(location = 0) out vec4 oColor;

        in vec2 fUV;
        in vec4 fColor;
        flat in int fTexture;

        // uniform sampler2D uSampler;
        uniform sampler2D uSampler[8];

        void main() {
            // oColor = vec4(1,1,1,1);
            // oColor = fColor;
            if (fTexture==-1){
                oColor = fColor;
            } else {
                oColor = fColor * texture(uSampler[fTexture], fUV);
            }
            // Text font needs to be white. Text color will be limited to some colors otherwise.
        };

        @strend
    
    window.base_shader = CreateShaderProgram(vshader, fshader)
    
    VBO: u32;
    VAO: u32;
    IBO: u32;

    glGenVertexArrays(1, &VAO);
    GLCHECK
    glGenBuffers(1, &VBO);
    GLCHECK
    glGenBuffers(1, &IBO);
    GLCHECK

    window.vao = VAO
    window.vbo = VBO
    window.ibo = IBO

    glBindVertexArray(VAO);
    GLCHECK
    
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    GLCHECK
    #macro BASE_SHADER_MAX_RECT 50
    #macro BASE_SHADER_MAX_VERTEX (4*BASE_SHADER_MAX_RECT)
    // #macro BASE_SHADER_VERTEX_STRIDE 2
    #macro BASE_SHADER_VERTEX_STRIDE 9
    glBufferData(GL_ARRAY_BUFFER, BASE_SHADER_MAX_VERTEX * BASE_SHADER_VERTEX_STRIDE * sizeof f32 , null, GL_DYNAMIC_DRAW);
    GLCHECK

    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, BASE_SHADER_VERTEX_STRIDE * sizeof f32, cast<void*>cast<u64>(0 * sizeof f32));
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, BASE_SHADER_VERTEX_STRIDE * sizeof f32, cast<void*>cast<u64>(2 * sizeof f32));
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(2, 4, GL_FLOAT, GL_FALSE, BASE_SHADER_VERTEX_STRIDE * sizeof f32, cast<void*>cast<u64>(4 * sizeof f32));
    glEnableVertexAttribArray(2);
    glVertexAttribPointer(3, 1, GL_FLOAT, GL_FALSE, BASE_SHADER_VERTEX_STRIDE * sizeof f32, cast<void*>cast<u64>(8 * sizeof f32));
    glEnableVertexAttribArray(3);
    
    indices: u32* = Allocate(6*BASE_SHADER_MAX_RECT * sizeof u32);
    defer Free(indices)
    for i: 0..BASE_SHADER_MAX_RECT {
        indices[i * 6] = i * 4 + 0;
        indices[i * 6 + 1] = i * 4 + 1;
        indices[i * 6 + 2] = i * 4 + 2;
        indices[i * 6 + 3] = i * 4 + 2;
        indices[i * 6 + 4] = i * 4 + 3;
        indices[i * 6 + 5] = i * 4 + 0;
    }
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, IBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, 6*BASE_SHADER_MAX_RECT*sizeof u32, indices, GL_STATIC_DRAW);
    
    // TODO: Don't hardcode font path
    window.font = CreateFont("assets/fonts/consolas42.png")

    return window;
}
// refresh screen buffer, poll events
fn RefreshWindow(window: WindowContext*) {
    
    // prev_timestamp 
    timestamp := StartMeasure()
    if window.prev_timestamp != 0
        window.delta = DiffMeasure(timestamp - window.prev_timestamp)
    else
        window.delta = 1./60.
    window.prev_timestamp = timestamp
    
    window.resetEvents(false)
    
    glfwSwapBuffers(window.glfw_window);
    glfwPollEvents();

    window.running = !glfwWindowShouldClose(window.glfw_window)

    // temporary
    ProcessSleep(0.001) // don't use up CPU resources
    // ProcessSleep(0.5) // don't use up CPU resources
    
    glViewport(0, 0, window.width, window.height)
    
    // user may not always want this
    // glClearColor(0.2, 0.2, 0.2, 1);
    // glClear(GL_COLOR_BUFFER_BIT);
}

/* ##################################
    Graphics library
    2. rendering functions
################################## */

struct Color {
    r: f32;
    g: f32;
    b: f32;
    a: f32 = 1.0;
}

fn FillColor(window: WindowContext*, color: Color) {
    glClearColor(color.r, color.g, color.b, color.a);
    glClear(GL_COLOR_BUFFER_BIT);
}
#macro CAM_VALUES
    bx := x              
    by := y              
    ox := 0.
    oy := 0.
    zoom := 1.
    if !window.enable_ui_space {
        zoom = window.camera_zoom
        bx -= window.width/2
        by -= window.height/2
        ox += -window.camera_x + window.width/2
        oy += -window.camera_y + window.height/2
    }
#endmacro
fn FillRect(window: WindowContext*, x: f32, y: f32, w: f32, h: f32, color: Color) {
    // @dumpbc
    glUseProgram(window.base_shader);
    
    glDisable(GL_DEPTH_TEST)
    glEnable(GL_BLEND)
    
    // glDisable(GL_CULL)
    
    // TODO: Store location in a map
    loc := glGetUniformLocation(window.base_shader, "uWindow".ptr)
    
    glUniform2f(loc,window.width,window.height);
    
    CAM_VALUES
    
    vertices: f32[] {
        // x ,y, uv.x, uv.y, color.rgba, texture
        (bx) *      zoom + ox, (by) *       zoom + oy, 0, 0, color.r, color.b, color.g, color.a, -1,
        (bx) *      zoom + ox, (by + h) *   zoom + oy, 0, 1, color.r, color.b, color.g, color.a, -1,
        (bx + w) *  zoom + ox, (by + h) *   zoom + oy, 1, 1, color.r, color.b, color.g, color.a, -1,
        (bx + w) *  zoom + ox, (by) *       zoom + oy, 1, 0, color.r, color.b, color.g, color.a, -1,
    }
    glBindBuffer(GL_ARRAY_BUFFER, window.vbo);
    glBufferSubData(GL_ARRAY_BUFFER, 0, 4 * BASE_SHADER_VERTEX_STRIDE * sizeof f32, vertices.ptr);
    glBindVertexArray(window.vao);
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, window.ibo);
    glDrawElements(GL_TRIANGLES, 6 * 1, GL_UNSIGNED_INT, null)
    
    // glDrawArrays(GL_TRIANGLES, 0, 3);
}
fn DrawTexture(window: WindowContext*, x: f32, y: f32, w: f32, h: f32, texture: Texture*) {
    glUseProgram(window.base_shader);
    
    glDisable(GL_DEPTH_TEST)
    glEnable(GL_BLEND)
    
    // glDisable(GL_CULL)
    
    strbuf: StringBuilder
    strbuf.append("uSampler[0]")
    loc_sample := glGetUniformLocation(window.base_shader, strbuf.ptr)
    sample_index := 0
    glUniform1i(loc_sample, sample_index);
    
    glActiveTexture(GL_TEXTURE0+0);
    glBindTexture(GL_TEXTURE_2D, texture.id);
    
    // TODO: Store location in a map
    loc := glGetUniformLocation(window.base_shader, "uWindow".ptr)
    
    glUniform2f(loc,window.width,window.height);
    
    color := Color{1,1,1}
     
    CAM_VALUES
    
    vertices: f32[] {
        // x ,y, uv.x, uv.y, color.rgba, texture
        (bx) *     zoom + ox, (by) *     zoom + oy, 0, 0, color.r, color.b, color.g, color.a, texture.id,
        (bx) *     zoom + ox, (by + h) * zoom + oy, 0, 1, color.r, color.b, color.g, color.a, texture.id,
        (bx + w) * zoom + ox, (by + h) * zoom + oy, 1, 1, color.r, color.b, color.g, color.a, texture.id,
        (bx + w) * zoom + ox, (by) *     zoom + oy, 1, 0, color.r, color.b, color.g, color.a, texture.id,
    }
    glBindBuffer(GL_ARRAY_BUFFER, window.vbo);
    glBufferSubData(GL_ARRAY_BUFFER, 0, 4 * BASE_SHADER_VERTEX_STRIDE * sizeof f32, vertices.ptr);
    glBindVertexArray(window.vao);
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, window.ibo);
    glDrawElements(GL_TRIANGLES, 6 * 1, GL_UNSIGNED_INT, null)
}
// TODO: Font* argument?
fn DrawText(window: WindowContext*, x: f32, y: f32, h: f32, text: char[]) {
    glUseProgram(window.base_shader);
    
    glDisable(GL_DEPTH_TEST)
    glEnable(GL_BLEND)
    
    // glDisable(GL_CULL)
    
    strbuf: StringBuilder
    strbuf.append("uSampler[0]")
    loc_sample := glGetUniformLocation(window.base_shader, strbuf.ptr)
    sample_index := 0
    glUniform1i(loc_sample, sample_index);
    
    font := window.font
    
    glActiveTexture(GL_TEXTURE0+0);
    glBindTexture(GL_TEXTURE_2D, font.id);
    
    // TODO: Store location in a map
    loc := glGetUniformLocation(window.base_shader, "uWindow".ptr)
    
    glUniform2f(loc,window.width,window.height);
    
    color := Color{1,1,1}
    
    CAM_VALUES
    
    // TODO: Batch draw calls
    off_x: i32 = 0
    off_y: f32 = 0
    for text {
        // log(it)
        if it == '\n' {
            off_y += h
            off_x = 0
            continue
        }

        u, v, uw, vh := font.get_uvwh(it)
        
        off := off_x * cast<f32> (font.char_width) / font.cell_h * h
        off_x++
        w := cast<f32> font.char_width / font.cell_w * h
        
        // log(it," ", off," ", w, " ", font.char_width)
        // log(it," ",u," ",v," ",uw," ",vh)
        
        vertices: f32[] {
            // x ,y, uv.x, uv.y, color.rgba, texture
            (bx + off) *     zoom + ox, (by + off_y) *     zoom + oy,     u,  v, color.r, color.b, color.g, color.a,  font.id,
            (bx + off) *     zoom + ox, (by + off_y + h) * zoom + oy, u,  vh, color.r, color.b, color.g, color.a, font.id,
            (bx + off + w) * zoom + ox, (by + off_y + h) * zoom + oy, uw, vh, color.r, color.b, color.g, color.a, font.id,
            (bx + off + w) * zoom + ox, (by + off_y) *     zoom + oy,     uw, v, color.r, color.b, color.g, color.a,  font.id,
        }
        glBindBuffer(GL_ARRAY_BUFFER, window.vbo);
        glBufferSubData(GL_ARRAY_BUFFER, 0, 4 * BASE_SHADER_VERTEX_STRIDE * sizeof f32, vertices.ptr);
        glBindVertexArray(window.vao);
        
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, window.ibo);
        glDrawElements(GL_TRIANGLES, 6 * 1, GL_UNSIGNED_INT, null)
    }
}

/* ################
    USER INPUT
################# */


/*###########################
    INTERNAL (user input)
###########################*/

#macro GLFW_CALLBACK_API @stdcall

global global_window_context: WindowContext*;
fn MapWindowContext(window: WindowContext*) {
    Assert(!global_window_context)
    // TODO: Do an actual mapping
    global_window_context = window;
} 
fn GetWindowContextByGLFWWindow(glfw_window: void*) -> WindowContext* {
    // TODO: Do an actual mapping
    return global_window_context;
}
// #macro LOG_GLFW_CALLBACK(...) log(...)
#macro LOG_GLFW_CALLBACK(...) #endmacro

fn GLFW_CALLBACK_API KeyCallback(window: void*, key: i32, scancode: i32, action: i32, mods: i32) {
    context := GetWindowContextByGLFWWindow(window);
    Assert(context)

    context.setInput(key, action != 0); // if not 0 means if pressed or repeating
    LOG_GLFW_CALLBACK("key ",cast<char>key, ",", key, " ", scancode, " ", mods, " ",action)

    // if (action != 0 && (key == GLFW_KEY_BACKSPACE || key == GLFW_KEY_DELETE || key == GLFW_KEY_ENTER || key == GLFW_KEY_LEFT || key == GLFW_KEY_RIGHT)) {
    //     CharCallback(window, key);
    // }
}
fn GLFW_CALLBACK_API MouseCallback(window: void*, button: i32, action: i32, mods: i32) {
    context := GetWindowContextByGLFWWindow(window);
    Assert(context)
    
    context.setInput(button, action != 0);
    LOG_GLFW_CALLBACK("click ", button, " ", action)
}
fn GLFW_CALLBACK_API CursorPosCallback(window: void*, mx: f64, my: f64) {
    context := GetWindowContextByGLFWWindow(window);
    Assert(context)
    context.setMouseX(cast<f32>mx);
    context.setMouseY(cast<f32>my);
    LOG_GLFW_CALLBACK("cursor ", mx," ", my)
}
fn GLFW_CALLBACK_API ScrollCallback(window: void*, xoffset: f64, yoffset: f64) {
    context := GetWindowContextByGLFWWindow(window);
    Assert(context)
    
    context.setScrollX(cast<f32>xoffset);
    context.setScrollY(cast<f32>yoffset);

    LOG_GLFW_CALLBACK("scroll ",xoffset, " ", yoffset)
}
fn GLFW_CALLBACK_API ResizeCallback(window: void*, width: i32, height: i32) {
    context := GetWindowContextByGLFWWindow(window);
    Assert(context)
    
    context.width = width
    context.height = height

    LOG_GLFW_CALLBACK("resize ",width, " ", height)
}
/*##############################
    SOME USEFUL FUNCTIONS
############################*/


// returns GLFWwindow*
fn InitGLFWAndCreateWindow(width: i32, height: i32) -> void* {
    yes := glfwInit();
    if !yes {
        log("glfwInit failed");
        return null;
    }
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    title := @cstr "Yes sir"
    window := glfwCreateWindow(width, height, title, null, null);
    if !window {
        log("window failed");
        glfwTerminate();
        return null;
    }

    glfwMakeContextCurrent(window);

    // err := glewInit();
    // if err {
        // msg := glewGetErrorString(err);
        // log("glew failed",msg)
        // glfwTerminate();
        // return null;
    // }
    yes = gladLoadGLLoader(glfwGetProcAddress);
    if !yes {
        log("gladLoadGL failed")
        glfwTerminate();
        return null;
    }

    glViewport(0, 0, width, height);
    GLCHECK

    glEnable(GL_BLEND)
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    // glEnable(GL_CULL)

    return window;
}
// returns program id which can be passes to glUseProgram
fn CreateShaderProgram(vshader: char[], fshader: char[]) -> u32 {
    vertexShader := glCreateShader(GL_VERTEX_SHADER);
    GLCHECK
    glShaderSource(vertexShader, 1, &vshader.ptr, null);
    GLCHECK
    glCompileShader(vertexShader);
    GLCHECK

    success: i32; // reused further down
    infoLog: char[512];
    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
    if !success {
        glGetShaderInfoLog(vertexShader, 512, null, infoLog.ptr);
        log("Vertex shader error: ",infoLog);
    }

    fragmentShader := glCreateShader(GL_FRAGMENT_SHADER);
    GLCHECK
    glShaderSource(fragmentShader, 1, &fshader.ptr, null);
    GLCHECK
    glCompileShader(fragmentShader);
    GLCHECK

    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
    GLCHECK
    if !success {
        glGetShaderInfoLog(fragmentShader, 512, null, infoLog.ptr);
        GLCHECK
        log("Fragment shader error: ",infoLog);
    }

    shaderProgram := glCreateProgram();
    GLCHECK
    glAttachShader(shaderProgram, vertexShader);
    GLCHECK
    glAttachShader(shaderProgram, fragmentShader);
    GLCHECK
    glLinkProgram(shaderProgram);
    GLCHECK

    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
    GLCHECK
    if !success {
        glGetProgramInfoLog(shaderProgram, 512, null, infoLog.ptr);
        GLCHECK
        log("Fragment shader error: ",infoLog);
    }
    
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);  

    return shaderProgram;
}
fn CreateTexture(path: char[]) -> Texture* {
    texture: Texture* = Allocate(sizeof Texture);
    *texture = Texture{}
    
    channels: i32
    stbi_set_flip_vertically_on_load(false);
    texture.data = stbi_load(path.ptr,&texture.width,&texture.height,&channels,4); // 4 = rgba
    texture.data_len = 4 * texture.width * texture.height
    
    glGenTextures(1, &texture.id);
    glBindTexture(GL_TEXTURE_2D,texture.id);
    // glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    // glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texture.width, texture.height, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture.data);
    GLCHECK
    glBindTexture(GL_TEXTURE_2D,0);
    GLCHECK
    
    return texture
}
fn CreateFont(path: char[]) -> Font* {
    font: Font* = Allocate(sizeof Font);
    *font = Font{}
    
    channels: i32
    stbi_set_flip_vertically_on_load(false);
    font.data = stbi_load(path.ptr,&font.width,&font.height,&channels,4); // 4 = rgba
    font.data_len = 4 * font.width * font.height
    
    glGenTextures(1, &font.id);
    glBindTexture(GL_TEXTURE_2D,font.id);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    // glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    // glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, font.width, font.height, 0, GL_RGBA, GL_UNSIGNED_BYTE, font.data);
    GLCHECK
    glBindTexture(GL_TEXTURE_2D,0);
    GLCHECK
    
    // hardcoded for consolas42.png
    font.char_width = 35;
    font.cell_w = font.width/16; // 16*16 = 256 characters
    font.cell_h = font.height/16;
    
    return font
}
fn DestroyTexture(texture: Texture*) {
    // TODO: destroy texture in OpenGL
        
    stbi_image_free(texture.data)
    Free(texture)
}   