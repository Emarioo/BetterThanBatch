/*
    A module for rendering things independent on the platform/operating system.
    
    DISCLAIMER: Currently only works on Windows (I don't have an Apple or Linux computer)
*/

// only OpenGL for now
#import "GLFW"
#import "GLAD"
#import "STB"
// #import "GLEW"

#import "Logger"
#import "Lang"
#import "Array"
#import "Memory"
#import "OS"

/* #####################################################
    GRAPHICS LIBRARY (depends on GLAD, GLFW, OPENGL)
    1. management
##################################################### */

struct WindowContext {
    glfw_window: void*;
    width: i32; // read only
    height: i32;
    running: bool = true;
    
    base_shader: u32;
    
    font: Font*;
    
    fn defaultFont() -> Font* {
        return font
    }
    
    vbo: u32;
    vao: u32;
    ibo: u32;
}
struct Texture {
    id: u32;
    width: i32;
    height: i32;
    
    // temporary?
    data: u8*;
    data_len: i32;
}
struct Font {
    id: u32;
    width:  i32;
    height: i32;
    
    char_width: i32;
    cell_w: i32;
    cell_h: i32;
    
    // temporary?
    data: u8*;
    data_len: i32;
    
    fn get_uvwh(chr: char) -> f32, f32, f32, f32 {
        return 
            cast<f32> cell_w * (cast<i32> chr % 16) / cast<f32> width,
            cast<f32> cell_h * (cast<i32> chr / 16) / cast<f32> height,
            cast<f32> cell_w * (cast<i32> chr % 16) / cast<f32> width + cast<f32>char_width / width,
            cast<f32> cell_h * (cast<i32> chr / 16) / cast<f32> height + cast<f32>cell_h / height;
    }
    fn width_of_text(text: char[], text_height: f32) -> f32 {
        return text.len * cast<f32> char_width/cast<f32>cell_h * text_height
    }
}

fn DestroyWindow(window: WindowContext*) {
    // TODO: Anything else to destroy? glfwTerminate if we only have one window left?
    
    glfwDestroyWindow(window.glfw_window)
    Free(window)
}
fn CreateWindow(width: i32, height: i32, title: char[] = "The beginning of something new") -> WindowContext* {
    yes := glfwInit();
    if !yes {
        log("glfwInit failed");
        return null;
    }
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfw_window := glfwCreateWindow(width, height, title.ptr, null, null);
    if !glfw_window {
        log("window failed");
        glfwTerminate();
        return null
    }

    glfwMakeContextCurrent(glfw_window)

    yes = gladLoadGL()
    // yes = gladLoadGLLoader(glfwGetProcAddress)
    if !yes {
        log("gladLoadGL failed")
        glfwTerminate()
        return null;
    }

    glViewport(0, 0, width, height)
    GLCHECK

    glEnable(GL_BLEND)
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
    // glEnable(GL_CULL)

    window: WindowContext* = Allocate(sizeof WindowContext);
    *window = WindowContext{}
    window.glfw_window = glfw_window
    window.width = width
    window.height = height
    
    vshader := @strbeg
        #version 330 core
        layout(location = 0) in vec2 vPos;
        layout(location = 1) in vec2 vUV;
        layout(location = 2) in vec4 vColor;
        layout(location = 3) in float vTexture;

        uniform vec2 uWindow;

        out vec2 fUV;
        out vec4 fColor;
        flat out int fTexture;

        void main() {	
            fUV=vUV;
            fColor=vColor;
            fTexture=int(vTexture);

            gl_Position = vec4((vPos.x)/uWindow.x*2.0-1.0, 1.0-(vPos.y)/uWindow.y*2.0, 0, 1);
            // gl_Position = vec4(vPos.x,vPos.y, 0, 1);
        };
        @strend;
    fshader := @strbeg
        #version 330 core
        layout(location = 0) out vec4 oColor;

        in vec2 fUV;
        in vec4 fColor;
        flat in int fTexture;

        // uniform sampler2D uSampler;
        uniform sampler2D uSampler[8];

        void main() {
            // oColor = vec4(1,1,1,1);
            // oColor = fColor;
            if (fTexture==-1){
                oColor = fColor;
            } else {
                oColor = fColor * texture(uSampler[fTexture], fUV);
            }
            // Text font needs to be white. Text color will be limited to some colors otherwise.
        };

        @strend
    
    window.base_shader = CreateShaderProgram(vshader, fshader)
    
    VBO: u32;
    VAO: u32;
    IBO: u32;

    glGenVertexArrays(1, &VAO);
    GLCHECK
    glGenBuffers(1, &VBO);
    GLCHECK
    glGenBuffers(1, &IBO);
    GLCHECK

    window.vao = VAO
    window.vbo = VBO
    window.ibo = IBO

    glBindVertexArray(VAO);
    GLCHECK
    
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    GLCHECK
    #macro BASE_SHADER_MAX_RECT 50
    #macro BASE_SHADER_MAX_VERTEX (4*BASE_SHADER_MAX_RECT)
    // #macro BASE_SHADER_VERTEX_STRIDE 2
    #macro BASE_SHADER_VERTEX_STRIDE 9
    glBufferData(GL_ARRAY_BUFFER, BASE_SHADER_MAX_VERTEX * BASE_SHADER_VERTEX_STRIDE * sizeof f32 , null, GL_DYNAMIC_DRAW);
    GLCHECK

    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, BASE_SHADER_VERTEX_STRIDE * sizeof f32, cast<void*>cast<u64>(0 * sizeof f32));
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, BASE_SHADER_VERTEX_STRIDE * sizeof f32, cast<void*>cast<u64>(2 * sizeof f32));
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(2, 4, GL_FLOAT, GL_FALSE, BASE_SHADER_VERTEX_STRIDE * sizeof f32, cast<void*>cast<u64>(4 * sizeof f32));
    glEnableVertexAttribArray(2);
    glVertexAttribPointer(3, 1, GL_FLOAT, GL_FALSE, BASE_SHADER_VERTEX_STRIDE * sizeof f32, cast<void*>cast<u64>(8 * sizeof f32));
    glEnableVertexAttribArray(3);
    
    indices: u32* = Allocate(6*BASE_SHADER_MAX_RECT * sizeof u32);
    defer Free(indices)
    for i: 0..BASE_SHADER_MAX_RECT {
        indices[i * 6] = i * 4 + 0;
        indices[i * 6 + 1] = i * 4 + 1;
        indices[i * 6 + 2] = i * 4 + 2;
        indices[i * 6 + 3] = i * 4 + 2;
        indices[i * 6 + 4] = i * 4 + 3;
        indices[i * 6 + 5] = i * 4 + 0;
    }
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, IBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, 6*BASE_SHADER_MAX_RECT*sizeof u32, indices, GL_STATIC_DRAW);
    
    // TODO: Don't hardcode font path
    window.font = CreateFont("assets/fonts/consolas42.png")

    return window;
}
// refresh screen buffer, poll events
fn RefreshWindow(window: WindowContext*) {
    glfwSwapBuffers(window.glfw_window);
    glfwPollEvents();

    window.running = !glfwWindowShouldClose(window.glfw_window)

    // temporary
    ProcessSleep(0.001) // don't use up CPU resources
    // ProcessSleep(0.5) // don't use up CPU resources
    
    // user may not always want this
    // glClearColor(0.2, 0.2, 0.2, 1);
    // glClear(GL_COLOR_BUFFER_BIT);
}

/* ##################################
    Graphics library
    2. rendering functions
################################## */

struct Color {
    r: f32;
    g: f32;
    b: f32;
    a: f32 = 1.0;
}

fn FillColor(window: WindowContext*, color: Color) {
    glClearColor(color.r, color.g, color.b, color.a);
    glClear(GL_COLOR_BUFFER_BIT);
}

fn FillRect(window: WindowContext*, x: f32, y: f32, w: f32, h: f32, color: Color) {
    // @dumpbc
    glUseProgram(window.base_shader);
    
    glDisable(GL_DEPTH_TEST)
    glEnable(GL_BLEND)
    
    // glDisable(GL_CULL)
    
    // TODO: Store location in a map
    loc := glGetUniformLocation(window.base_shader, "uWindow".ptr)
    
    glUniform2f(loc,window.width,window.height);
    
    vertices: f32[] {
        // x ,y, uv.x, uv.y, color.rgba, texture
        x, y, 0, 0, color.r, color.b, color.g, color.a, -1,
        x, y + h, 0, 1, color.r, color.b, color.g, color.a, -1,
        x + w, y + h, 1, 1, color.r, color.b, color.g, color.a, -1,
        x + w , y, 1, 0, color.r, color.b, color.g, color.a, -1,
    }
    glBindBuffer(GL_ARRAY_BUFFER, window.vbo);
    glBufferSubData(GL_ARRAY_BUFFER, 0, 4 * BASE_SHADER_VERTEX_STRIDE * sizeof f32, vertices.ptr);
    glBindVertexArray(window.vao);
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, window.ibo);
    glDrawElements(GL_TRIANGLES, 6 * 1, GL_UNSIGNED_INT, null)
    
    // glDrawArrays(GL_TRIANGLES, 0, 3);
}
fn DrawTexture(window: WindowContext*, x: f32, y: f32, w: f32, h: f32, texture: Texture*) {
    glUseProgram(window.base_shader);
    
    glDisable(GL_DEPTH_TEST)
    glEnable(GL_BLEND)
    
    // glDisable(GL_CULL)
    
    strbuf: StringBuilder
    strbuf.append("uSampler[0]")
    loc_sample := glGetUniformLocation(window.base_shader, strbuf.ptr)
    sample_index := 0
    glUniform1i(loc_sample, sample_index);
    
    glActiveTexture(GL_TEXTURE0+0);
    glBindTexture(GL_TEXTURE_2D, texture.id);
    
    // TODO: Store location in a map
    loc := glGetUniformLocation(window.base_shader, "uWindow".ptr)
    
    glUniform2f(loc,window.width,window.height);
    
    color := Color{1,1,1}
    
    vertices: f32[] {
        // x ,y, uv.x, uv.y, color.rgba, texture
        x, y, 0, 0, color.r, color.b, color.g, color.a, texture.id,
        x, y + h, 0, 1, color.r, color.b, color.g, color.a, texture.id,
        x + w, y + h, 1, 1, color.r, color.b, color.g, color.a, texture.id,
        x + w , y, 1, 0, color.r, color.b, color.g, color.a, texture.id,
    }
    glBindBuffer(GL_ARRAY_BUFFER, window.vbo);
    glBufferSubData(GL_ARRAY_BUFFER, 0, 4 * BASE_SHADER_VERTEX_STRIDE * sizeof f32, vertices.ptr);
    glBindVertexArray(window.vao);
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, window.ibo);
    glDrawElements(GL_TRIANGLES, 6 * 1, GL_UNSIGNED_INT, null)
}
// TODO: Font* argument?
fn DrawText(window: WindowContext*, x: f32, y: f32, h: f32, text: char[]) {
    glUseProgram(window.base_shader);
    
    glDisable(GL_DEPTH_TEST)
    glEnable(GL_BLEND)
    
    // glDisable(GL_CULL)
    
    strbuf: StringBuilder
    strbuf.append("uSampler[0]")
    loc_sample := glGetUniformLocation(window.base_shader, strbuf.ptr)
    sample_index := 0
    glUniform1i(loc_sample, sample_index);
    
    font := window.font
    
    glActiveTexture(GL_TEXTURE0+0);
    glBindTexture(GL_TEXTURE_2D, font.id);
    
    // TODO: Store location in a map
    loc := glGetUniformLocation(window.base_shader, "uWindow".ptr)
    
    glUniform2f(loc,window.width,window.height);
    
    color := Color{1,1,1}
    
    // TODO: Batch draw calls
    for text {
        // log(it)
        u, v, uw, vh := font.get_uvwh(it)
        
        off := nr * cast<f32> (font.char_width) / font.cell_h * h
        w := cast<f32> font.char_width / font.cell_w * h
        
        // log(it," ", off," ", w, " ", font.char_width)
        // log(it," ",u," ",v," ",uw," ",vh)
        
        vertices: f32[] {
            // x ,y, uv.x, uv.y, color.rgba, texture
            x + off,     y,     u,  v, color.r, color.b, color.g, color.a,  font.id,
            x + off,     y + h, u,  vh, color.r, color.b, color.g, color.a, font.id,
            x + off + w, y + h, uw, vh, color.r, color.b, color.g, color.a, font.id,
            x + off + w, y,     uw, v, color.r, color.b, color.g, color.a,  font.id,
        }
        glBindBuffer(GL_ARRAY_BUFFER, window.vbo);
        glBufferSubData(GL_ARRAY_BUFFER, 0, 4 * BASE_SHADER_VERTEX_STRIDE * sizeof f32, vertices.ptr);
        glBindVertexArray(window.vao);
        
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, window.ibo);
        glDrawElements(GL_TRIANGLES, 6 * 1, GL_UNSIGNED_INT, null)
    }
}


/*##############################
    SOME USEFUL FUNCTIONS
############################*/


// returns GLFWwindow*
fn InitGLFWAndCreateWindow(width: i32, height: i32) -> void* {
    yes := glfwInit();
    if !yes {
        log("glfwInit failed");
        return null;
    }
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    title := @cstr "Yes sir"
    window := glfwCreateWindow(width, height, title, null, null);
    if !window {
        log("window failed");
        glfwTerminate();
        return null;
    }

    glfwMakeContextCurrent(window);

    // err := glewInit();
    // if err {
        // msg := glewGetErrorString(err);
        // log("glew failed",msg)
        // glfwTerminate();
        // return null;
    // }
    yes = gladLoadGLLoader(glfwGetProcAddress);
    if !yes {
        log("gladLoadGL failed")
        glfwTerminate();
        return null;
    }

    glViewport(0, 0, width, height);
    GLCHECK

    glEnable(GL_BLEND)
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    // glEnable(GL_CULL)

    return window;
}

// returns program id which can be passes to glUseProgram
fn CreateShaderProgram(vshader: char[], fshader: char[]) -> u32 {
    vertexShader := glCreateShader(GL_VERTEX_SHADER);
    GLCHECK
    glShaderSource(vertexShader, 1, &vshader.ptr, null);
    GLCHECK
    glCompileShader(vertexShader);
    GLCHECK

    success: i32; // reused further down
    infoLog: char[512];
    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
    if !success {
        glGetShaderInfoLog(vertexShader, 512, null, infoLog.ptr);
        log("Vertex shader error: ",infoLog);
    }

    fragmentShader := glCreateShader(GL_FRAGMENT_SHADER);
    GLCHECK
    glShaderSource(fragmentShader, 1, &fshader.ptr, null);
    GLCHECK
    glCompileShader(fragmentShader);
    GLCHECK

    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
    GLCHECK
    if !success {
        glGetShaderInfoLog(fragmentShader, 512, null, infoLog.ptr);
        GLCHECK
        log("Fragment shader error: ",infoLog);
    }

    shaderProgram := glCreateProgram();
    GLCHECK
    glAttachShader(shaderProgram, vertexShader);
    GLCHECK
    glAttachShader(shaderProgram, fragmentShader);
    GLCHECK
    glLinkProgram(shaderProgram);
    GLCHECK

    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
    GLCHECK
    if !success {
        glGetProgramInfoLog(shaderProgram, 512, null, infoLog.ptr);
        GLCHECK
        log("Fragment shader error: ",infoLog);
    }
    
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);  

    return shaderProgram;
}

fn CreateTexture(path: char[]) -> Texture* {
    texture: Texture* = Allocate(sizeof Texture);
    *texture = Texture{}
    
    channels: i32
    stbi_set_flip_vertically_on_load(false);
    texture.data = stbi_load(path.ptr,&texture.width,&texture.height,&channels,4); // 4 = rgba
    texture.data_len = 4 * texture.width * texture.height
    
    glGenTextures(1, &texture.id);
    glBindTexture(GL_TEXTURE_2D,texture.id);
    // glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    // glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texture.width, texture.height, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture.data);
    GLCHECK
    glBindTexture(GL_TEXTURE_2D,0);
    GLCHECK
    
    return texture
}
fn CreateFont(path: char[]) -> Font* {
    font: Font* = Allocate(sizeof Font);
    *font = Font{}
    
    channels: i32
    stbi_set_flip_vertically_on_load(false);
    font.data = stbi_load(path.ptr,&font.width,&font.height,&channels,4); // 4 = rgba
    font.data_len = 4 * font.width * font.height
    
    glGenTextures(1, &font.id);
    glBindTexture(GL_TEXTURE_2D,font.id);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    // glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    // glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, font.width, font.height, 0, GL_RGBA, GL_UNSIGNED_BYTE, font.data);
    GLCHECK
    glBindTexture(GL_TEXTURE_2D,0);
    GLCHECK
    
    // hardcoded for consolas42.png
    font.char_width = 35;
    font.cell_w = font.width/16; // 16*16 = 256 characters
    font.cell_h = font.height/16;
    
    return font
}
fn DestroyTexture(texture: Texture*) {
    // TODO: destroy texture in OpenGL
        
    stbi_image_free(texture.data)
    Free(texture)
}   