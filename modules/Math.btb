
// log2
// log10
// loge
// sin
// cos
// tan
// asin,acos,atan2?

#import "OS"

fn @intrinsic sqrt(v: f32) -> f32;
fn @intrinsic round(v: f32) -> f32;
// TODO: Intrinsics for min and max


// TODO: Pseudo random generator with seeds
fn random64() -> u64 {
    num: u64;
#if OS_WINDOWS       
    // NTSTATUS BCryptGenRandom(
    // [in, out] BCRYPT_ALG_HANDLE hAlgorithm,
    // [in, out] PUCHAR            pbBuffer,
    // [in]      ULONG             cbBuffer,
    // [in]      ULONG             dwFlags
    // );
    #load "Bcrypt.lib" as bcrypt
    fn @import(bcrypt) BCryptGenRandom(_: void*, buf: void*, len: u32, flags: u32) -> i32;
    #macro BCRYPT_USE_SYSTEM_PREFERRED_RNG cast<u32>0x00000002
    
    status := BCryptGenRandom(null, &num, sizeof num, BCRYPT_USE_SYSTEM_PREFERRED_RNG);
    if status < 0;
        *cast<u32*>null;
        // TODO: Assert
    
#elif OS_UNIX
    fn @import @unixcall getrandom(buf: void*, len: u64, flags: u32) -> i64;
    bytes := getrandom(&num, sizeof num, 0);
    if bytes != 8 {
        *cast<u32*>null;
        // TODO: Assert
    }
#else
    missing_impl
#endif
    return num;
}
// random between 0.0 and 1.0
fn random_f32() -> f32 {
    // x64 generator can't convert u64 to f32 so we do i64 instead.
    // BUT, we don't want any negative numbers to we mask off the signed bit.
    mask: i64 = 0x7FFF_FFFF_FFFF_FFFF;
    return cast<f32>(cast<i64>random64() & mask) / cast<f32>(0xFFFF_FFFF_FFFF_FFFF & mask);
}

// TODO: Test it
struct RandomGenerator {
    seed: u64;
    _state32: u32;
    _state64: u64;
    fn rand32() -> u32 {
        // https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/
        state: u32 = _state32;
        _state32 = _state32 * 747796405u + 2891336453u;
        word: u32 = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
        return (word >> 22u) ^ word;
    }
    fn rand64() -> u64 {
        // https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/
        // https://en.wikipedia.org/wiki/Permuted_congruential_generator#Variants
        // https://github.com/imneme/pcg-c/blob/master/include/pcg_variants.h#L276
        state: u64 = _state64;
        _state64 = _state64 * 6364136223846793005u + 1442695040888963407u;
        word: u64 = ((state >> ((state >> 59u) + 5u)) ^ state) * 12605985483714917081u;
        return (word >> 43u) ^ word;
    }
}
fn create_random_generator(seed: u64 = StartMeasure()) -> RandomGenerator {
    return RandomGenerator{seed = seed, _state32 = seed, _state64 = seed};
}


// From NativeLayer
// fn @import sine(f: f32) -> f32;

// These come from the C standard library
// fn @import sinf(f: f32) -> f32;
// fn @import cosf(f: f32) -> f32;
// fn @import tanf(f: f32) -> f32;
// fn @import log10f(f: f32) -> f32;
// fn @import log2f(f: f32) -> f32;
// fn @import logf(f: f32) -> f32;

// Not tested yet
// fn exp(x: f32, y: i32) -> f32{
//     if y < 0 {
//         out = 1;
//         for 0..y {
//             out /= x;
//         }
//     } else {
//         out = 1;
//         for 0..y {
//             out *= x;
//         }
//     }
// }

// TODO: Move elsewhere?
// TODO: Not tested
// TODO: Optimize
// Assumes the slice/array to be sorted
// returns the index of the item. -1 if not found
// fn binary_search<T>(arr: T[], item: T) -> i32 {
//     left: u32 = 0
//     right: u32 = arr.len // bad, casting u64 to u32
//     while {
//         mid := (left + right)/2 // integer overflow?
//         elem := arr.ptr[mid]
//         if item < elem {
//             right = mid - 1
//         } else item > elem {
//             left = mid + 1
//         } else {
//             return mid;
//         }

//     }
// }

struct f16 {
    bits: u16;
    fn sign() -> i32 { return cast<u32>(bits >> 15) & 0x1u }
    fn exp() -> i32 { return cast<u32>(bits >> 10) & 0x1Fu }
    fn mantissa() -> i32 { return cast<u32>(bits >> 0) & 0x3FFu }
}
fn make_f16(f: f32) -> f16 {
    tmp: i32 = cast_unsafe<i32>f
    sign := tmp >> 31
    exp := tmp >> 23
    if exp & 0x80
        exp = ((exp -127) & 0xf) + 15
    else
        exp = exp & 0xF
    mantissa := (tmp >> 13) & 0x3FF
    return make_f16(sign, exp, mantissa)
}
fn make_f16(sign: i32, exp: i32, mantissa: i32) -> f16 {
    return f16{((sign&1)<<15) | ((exp & 0x1F) << 10) | (mantissa & 0x3FF) }
}

fn add(a: f16, b: f16) -> f16 {
    sign := (a.bits >> 15)  ^ (b.bits >> 15)
    
    a_exp := a.exp()
    b_exp := b.exp()
    
    exp: i32
    mant: i32
    diff := a_exp - b_exp
    if diff > 0 {
        mant = (a.mantissa() | 0x400) << diff + (b.mantissa() | 0x400)
        if mant & (0x400 << diff) { // overflow of mantissa
            exp = a_exp + 1
            mant = mant >> (diff + 1)
        } else {
            exp = a_exp
            mant = mant >> (diff)
        }
    } else if diff < 0 {
        mant = (a.mantissa() | 0x400) + (b.mantissa() | 0x400) << -diff
        if mant & (0x400 << -diff) { // overflow of mantissa
            exp = b_exp + 1
            mant = mant >> (-diff + 1)
        } else {
            exp = b_exp
            mant = mant >> (-diff)
        }
    } else {
        mant = a.mantissa() + b.mantissa()
        exp = a_exp + 1
        mant = mant >> 1
    }
    return make_f16(sign, exp, mant)
}
fn sub(a: f16, b: f16) -> f16 {
    return add(a, cast_unsafe<f16>(cast<u16>0x8000^b.bits))
}
operator +(a: f16, b: f16) -> f16 { return add(a, b) }
operator -(a: f16, b: f16) -> f16 { return sub(a, b) }

fn std_print(f: f16) {
    bits: u32 = cast_unsafe<u16>f;
    
    sign := (bits >> 15u) & 1u;
    exp := (bits >> 10u) & 0x1Fu;
    mantissa: u64 = 0x400u | (bits & 0x3FFu)

    if sign
        std_print('-');
        
    intPart: u64 = 0;
    decimalBits: i32 = 10 - (exp-15);

    if decimalBits < 1 {
        intPart = (mantissa) << (0-decimalBits);
        if intPart == 0 {
            printc('0')
        } else {
            str: char[23];
            used := 22;
            while intPart > 0u && used > 0 {
                digit: u8 = intPart % 10u;
                // log("i",intPart);
                // log("d",digit);
                str.ptr[used] = digit + '0';
                used--;
                intPart = intPart / 10u;
            }
            str.ptr += used + 1;
            str.len -= used + 1;
            prints(str);
        }
        // std_print(intPart);
        std_print('.');
        std_print('0');
    } else {
        if exp >= 15u
            intPart = (mantissa) >> decimalBits;
        std_print(cast<i64>intPart);
        std_print('.');

        decimals: char[24];

        acc: u64 = 0;
        mul: u64 = 1;
        // std_print(decimalBits); std_print('\n')
        precision := 19; // digits u64 can contain (18446744073709551615)
        minBits :i32= decimalBits - precision;
        if minBits < 0 {
            minBits = 0;
        }
        // log(minBits, decimalBits)
        for @rev minBits..decimalBits {
            mul *= 5u;
            acc = acc*10u
            // log("nr", nr)
            if nr < 24 {
                bit := cast<u64>1 & (mantissa >> nr)
                if bit {
                    acc += mul;
                }
                // std_print(acc); std_print('\n')
            }
        }
        // std_print(acc);
        if acc == 0
            std_print('0');
        blank := true;
        lastZero := 0
        limit := precision;
        if decimalBits < precision;
            limit = decimalBits;
        for @rev 0..limit {
            digit := acc % 10u;
            acc = acc / 10u;
            if !blank || digit != 0 {
                decimals.ptr[nr] = digit + '0';
                if blank
                    lastZero = nr+1
                blank = false;
            }
        }
        decimals.len = lastZero;
        std_print(decimals)
    }
}