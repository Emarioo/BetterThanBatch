/*
    Standard API for threads
    
    IMPORTANT: THREADS ARE NOT SUPPORTED IN THE VirtualMachine! yet?
*/

#if OS_WINDOWS
    #import "Windows"
#elif OS_LINUX
    #import "Linux"
#endif

/* Logic of compare and swap
if *ptr == old
    *ptr = new
    return old
else
    return *ptr
*/
fn @intrinsic atomic_compare_swap(ptr: i32*, old: i32, new: i32) -> i32;
fn @intrinsic atomic_add(ptr: i32*, value: i32) -> i32;
// TODO: atomic_add64?

struct Thread {
    os_handle: u64 = 0;
    id: u64 = 0;
    
    fn cleanup() {
        os_handle = 0
        id = 0
    }
    fn valid() -> bool {
        return id != 0
    }
}

// TODO: Implement @oscall which chooses convention based on targeted system.
// TODO: Windows threads returns integer while Linux threads return void*. Writing a program that works on both could be troublesome because of the different return value. How do deal with it?
#if OS_WINDOWS
#macro FnThread fn @stdcall (void*)->i32
#else
#macro FnThread fn @unixcall (void*)->void*
#endif

#macro ThreadId u64
// func should be fn @unixcall/@stdcall (void*) -> void*
fn ThreadCreate(func: FnThread, param: void*) -> Thread {
    // TODO: Handle error
    thread: Thread;
    #if OS_WINDOWS
        threadId: u32 = 0;
        thread.os_handle = cast_unsafe<u64>CreateThread(null, 0, func, param, null, &threadId);
        thread.id = threadId;
    #else
        threadId: u32 = 0;
        temp: pthread_t;
        err = pthread_create(&temp, null, func, param);
        thread.os_handle = cast_unsafe<u64>temp;
        thread.id = cast_unsafe<u64>temp;
    #endif
    return thread;
}
// fn ThreadDestroy(thread: Thread) {
//     // TODO: Handle error
//     #if OS_WINDOWS
//         CloseHandle(thread.os_handle);
//     #else
//         ThreadJoin(thread); // nocheckin TODO: temporary
//     #endif
// }
fn ThreadJoin(thread: Thread) {
    // TODO: Handle error
    #if OS_WINDOWS
        WaitForSingleObject(thread.os_handle, 0xFFFFFFFF); // 0xFFFFFFFF wait indefinitely
        CloseHandle(thread.os_handle);
    #else
        // Assert(sizeof(pthread) == sizeof(thread.os_handle));
        err = pthread_join(cast_unsafe<pthread_t>thread.os_handle, cast_unsafe<void**>null);
    #endif
}
fn ThreadSelfId() -> ThreadId {
    #if OS_WINDOWS
        return cast_unsafe<u64>pthread_self();
    #else
        return GetCurrentThreadId();
    #endif
}

// TODO: Mutex
