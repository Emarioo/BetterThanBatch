/*
## Module for the file system ##
- Opening, reading, writing files
- Creating, iterating directories
- TODO: File monitoring
*/

#import "Memory"
#import "String"
#import "OS"
#import "Lang" // temporary

#if OS_WINDOWS
#import "Win32"
#elif OS_LINUX
#import "Linux"
#endif

enum @enclosed FileHandle : i64 { INVALID }

// TODO: These should be scoped to this file
fn HandleToInternal(n: FileHandle) -> i64 {
    return cast<void*> ( cast<i64>n - 1 )
}
fn InternalToHandle(n: i64) -> FileHandle {
    return cast_unsafe<FileHandle> ( cast<i64>n + 1 )
}

enum @specified FileOpenFlags {
    FILE_READ_ONLY          = 0x1,
    FILE_CLEAR_AND_WRITE    = 0x2,
    FILE_READ_AND_WRITE     = 0x4,
}
// returns file handle and file size
fn FileOpen(path: Slice<char>, flags: FileOpenFlags, outFileSize: i64* = null) -> FileHandle {
    c_path: char* = path.ptr;
    destroy_c_path := false
    defer {
        if destroy_c_path
            Free(c_path)
    }
    if path.ptr[path.len] != '\0' {
        destroy_c_path = true
        c_path = Allocate(path.len + 1)
        memcpy(c_path, path.ptr, path.len)
        c_path[path.len] = '\0'
    }

#if OS_WINDOWS
    access: i32 = GENERIC_READ|GENERIC_WRITE
    sharing: i32 = FILE_SHARE_READ|FILE_SHARE_WRITE
    
    if flags & FILE_READ_ONLY
        access = GENERIC_READ
    
    creation: i32 = OPEN_EXISTING;
    if flags & FILE_CLEAR_AND_WRITE
        creation = CREATE_ALWAYS;
    
    // if(creation&OPEN_ALWAYS||creation&CREATE_ALWAYS){
    //     std::string temp;
    //     uint i=0;
    //     int at = path.find_first_of(':');
    //     if(at!=-1){
    //         i = at+1;
    //         temp+=path.substr(0,i);
    //     }
    //     for(;i<path.length();i++){
    //         char chr = path[i];
    //         if(chr=='/'||chr=='\\'){
    //             // printf("exist %s\n",temp.c_str());
    //             if(!DirectoryExist(temp)){
    //                 // printf(" create\n");
    //                 bool success = DirectoryCreate(temp);
    //                 if(!success)
    //                     break;
    //             }
    //         }
    //         temp+=chr;
    //     }
    // }
    security_attributes := null // TODO: Can we ignore securit attributes?
    // SECURITY_ATTRIBUTES sa;
    // ZeroMemory(&sa, sizeof(SECURITY_ATTRIBUTES));
    // sa.nLength = sizeof(sa);
    // sa.bInheritHandle = true;
    
    handle := CreateFileA(c_path,access,sharing,security_attributes,creation,FILE_ATTRIBUTE_NORMAL, null);
    
    if(handle == INVALID_HANDLE_VALUE){
        // TODO: provide a better error
        return FileHandle.INVALID
        // DWORD err = GetLastError();
        // if(err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND){
        //     // this can happen, it's not really an error, no need to print.
        //     // denied access to some more fundamental error is important however.
        //     // PL_PRINTF("[WinError %lu] Cannot find '%s'\n",err,path.c_str());
        // }else if(err == ERROR_ACCESS_DENIED){
        //     PL_PRINTF("[WinError %lu] Denied access to '%s'\n",err,path.c_str()); // tried to open a directory?
        // }else {
        //     PL_PRINTF("[WinError %lu] Error opening '%s'\n",err,path.c_str());
        // }
        // return {};
    } else if (outFileSize) {
        *outFileSize = 0;
        
        success := GetFileSizeEx(handle, outFileSize);
        if (!success) {
            success := CloseHandle(handle)
            if !success {
                // TODO: I don't think this should fail since CreateFileA succeded.   
            }
            return FileHandle.INVALID
        }
    }
    return InternalToHandle(handle)
#elif OS_LINUX
    open_flags, mode: i32
    
    if flags & FILE_READ_ONLY
        open_flags = O_RDONLY
    if flags & FILE_READ_AND_WRITE
        open_flags = O_RDWR
    if flags & FILE_CLEAR_AND_WRITE {
        fileFlags = O_CREAT | O_TRUNC | O_RDWR;
        mode = S_IRUSR | S_IWUSR;
    }

    fd := open(c_path, open_flags, mode)
    if fd == -1
        return InternalToHandle(-1)

    if outFileSize {
        info: stat
        res := fstat(fd, &info)
        if res == -1 {
            *outFileSize = 0 // TODO: handle error
        } else
            *outFileSize = info.st_size
    }
    return InternalToHandle(fd)
#endif
}
// returns read bytes
fn FileRead(file: FileHandle, buffer: void*, size: i32) -> i32 {
    read: i32
    yes := ReadFile(HandleToInternal(file), buffer, size, &read, null)
    if !yes
        return 0 // TODO: Handle error
    return read
}
// returns written bytes
fn FileWrite(file: FileHandle, buffer: void*, size: i32) -> i32 {
    written: i32
    yes := WriteFile(HandleToInternal(file), buffer, size, &written, null)
    if !yes
        return 0 // TODO: Handle error
    return written
}
fn FileClose(file: FileHandle) {
    CloseHandle(HandleToInternal(file))
}

// // The returned string is heap allocated in the interpreter.
// // This allocation is freed when the interpreter finishes.
// // TODO: You may want to change this so that you give the function a
// //   StringBuffer or StringBuilder and it puts the CWD in there while
// //   still returning a slice. Perhaps the StringBuilder defaults to null
// //   and if not provided it is heap allocated, otherwise allocated in StringBuilder.
// fn CurrentWorkingDirectory() -> char[]; // should it be const?

// struct DirectoryIteratorData {
//     name: char[]; // Allocated by interpreter; can't be String because of that. The ptr should be const (char* const NOT const char*)
//     fileSize: u64;
//     lastWriteSeconds: f32;
//     isDirectory: bool;
// }
// struct DirectoryIterator {
//     _handle: u64;
//     rootPath: char[]; // allocated by interpreter, should be char* const
//     result: DirectoryIteratorData;

//     fn next() -> DirectoryIteratorData* {
//         return DirectoryIteratorNext(this);
//     }
//     fn skip() {
//         DirectoryIteratorSkip(this);
//     }
// }

struct DirIteratorItem {
    name: StringBuilder;
    file_size: u64;
    last_write_time: u64;
    is_directory: bool;
}

// A handle to hide implementation details
enum @enclosed DirIterator : i64 { INVALID }
fn InternalToIterator(n: i32) -> DirIterator { return cast_unsafe<DirIterator>cast<i64>(n+1) }
fn IteratorToInternal(n: DirIterator) -> i32 { return cast<i32>cast<i64>n-1 }

// TODO: We depend on Array and StringBuilder for quick implementation of dir iterators
//   but it would be nice to not depend on them.
#import "Array"
#import "String"

// TODO: Temporarily importing logger for debugging
#import "Logger"

struct DirIterator_impl {
    root: StringBuilder;
    current_dir: StringBuilder;
    remaining_directories: Array<StringBuilder>;
    
    item: DirIteratorItem;
    
    fn valid() -> bool { return root.ptr }
    
    fn cleanup() {
        root.cleanup()
        current_dir.cleanup()
        for remaining_directories.sliced_unsafe()
            it.cleanup()   
        item.name.cleanup()
    }
    #if OS_WINDOWS
    handle: HANDLE;
    #elif OS_LINUX
    fd_current_dir: i32;
    head: i32;
    bytes_in_buffer: i32;
    buffer: char[1024];
    #endif
}

global _directory_iterators: Array<DirIterator_impl*>

fn DirectoryIteratorCreate(root_path: char[]) -> DirIterator {
    if root_path.len == 0 
        return DirIterator.INVALID // empty path not okay
    
    index: i32 = -1
    for 0.._directory_iterators.size() {
        iter := _directory_iterators.get(nr)
        if iter {
            if iter.valid() // TODO: Use &&
                continue
            else {
                log("REALLY BAD ERROR IN DIRECTORY ITERATOR CREATE")
            }
        }
        index = nr
        iter = AllocateHeap(sizeof DirIterator_impl)
        memzero(iter, sizeof *iter)
        _directory_iterators.ptr[index] = iter
        break
    }
    if index == -1 {
        it := AllocateHeap(sizeof DirIterator_impl)
        memzero(it, sizeof *it)
        _directory_iterators.add(it)
        index = _directory_iterators.size()-1
    }
    
    iter := _directory_iterators.get(index)
    
    iter.root.append(root_path)
    iter.remaining_directories.add(iter.root.copy())
    #if OS_WINDOWS
    iter.handle = -1
    #elif OS_LINUX
    iter.fd_current_dir = -1
    iter.head = 0
    #else
    incomplete
    #endif
    
    return InternalToIterator(cast<i64>index)
}
fn DirectoryIteratorDestroy(iterator: DirIterator) {
    if iterator == DirIterator.INVALID
        return
    index := IteratorToInternal(iterator)
    iter := _directory_iterators.get(index)
    
    #if OS_WINDOWS
    if iter.handle != INVALID_HANDLE_VALUE {
        yes := FindClose(iter.handle)
        if !yes {
            // TODO: Handle error
        }
    }
    #elif OS_LINUX
    if iter.fd_current_dir != -1 {
        yes := close(iter.fd_current_dir)
        if yes < 0 {
            // TODO: Handle error   
        }
    }
    #else
    incomplete
    #endif
    
    iter.cleanup()

    AllocateHeap(0, iter)
    _directory_iterators.ptr[index] = null
}
fn DirectoryIteratorNext(iterator: DirIterator, out_item: DirIteratorItem**) -> bool {
    if iterator == DirIterator.INVALID
        return false
    index := IteratorToInternal(iterator)
    iter := _directory_iterators.get(index)
    
    #if OS_WINDOWS
    data: WIN32_FIND_DATAA
    cFileNameLen: i32
    while {
        if(iter.handle==INVALID_HANDLE_VALUE){
            if(iter.remaining_directories.size()==0){
                return false;
            }
            iter.current_dir.clear();
            
            dir := iter.remaining_directories.get(0);
            iter.remaining_directories.remove(0);
            
            if(dir.size()!=0){
                iter.current_dir.append(dir.sliced());
            }
            
            temp: StringBuilder = iter.current_dir.copy();
            if(temp.size())
                temp.append("\\");
            
            temp.append("*");
            handle: HANDLE = INVALID_HANDLE_VALUE;
            handle = FindFirstFileA(temp.data(),&data);
            
            if(handle==INVALID_HANDLE_VALUE){
                log("find first file failed")
                // DWORD err = GetLastError();
                // PL_PRINTF("[WinError %lu] FindNextFileA '%llu'\n",err,(u64)iterator);
                continue;
            }
            iter.handle = handle;
        }else{
            success := FindNextFileA(iter.handle,&data);
            if(!success){
                // TODO: Check GetLastError
                // DWORD err = GetLastError();
                // if(err == ERROR_NO_MORE_FILES){
                //     // PL_PRINTF("[WinError %u] No files '%lu'\n",err,(u64)iterator);
                // }else {
                //     PL_PRINTF("[WinError %lu] FindNextFileA '%llu'\n",err,(u64)iterator);
                // }
                success := FindClose(iter.handle);
                iter.handle = INVALID_HANDLE_VALUE;
                if(!success){
                    log("find close failed")
                    // TODO: Check GetLastError
                    // err = GetLastError();
                    // PL_PRINTF("[WinError %lu] FindClose '%llu'\n",err,(u64)iterator);
                }
                continue;
            }
        }
        // fprintf(stderr, "%p %p\n", iterator, result);
        if(equal(data.cFileName.ptr,".") || equal(data.cFileName.ptr,"..")){
            continue;
        }
        cFileNameLen = strlen(data.cFileName.ptr)
        if cFileNameLen == 0
            continue
        break;
    }
    
    iter.item.name.clear()
    
    if iter.current_dir.size() {
        iter.item.name.append(iter.current_dir.sliced())
        iter.item.name.append("/")
        iter.item.name.append(data.cFileName.ptr, cFileNameLen)
    } else {
        iter.item.name.append(data.cFileName.ptr, cFileNameLen)
    }
    #macro MAXDWORD 0xFFFF_FFFFu
    iter.item.file_size = cast<u64>data.nFileSizeLow+cast<u64>data.nFileSizeHigh*(MAXDWORD+1u);
    iter.item.last_write_time = cast<u64>data.ftLastWriteTime.dwLowDateTime+cast<u64>data.ftLastWriteTime.dwHighDateTime*(MAXDWORD+1u);
    
    iter.item.is_directory = data.dwFileAttributes&cast<i32>FILE_ATTRIBUTE_DIRECTORY;
    if(iter.item.is_directory){
        iter.remaining_directories.add(iter.item.name.copy());
    }

    for 0..iter.item.name.size() {
        if iter.item.name[nr] == '\\'
            iter.item.name.data()[nr] = '/';
    }
    #elif OS_LINUX

    file_name: char*;
    file_name_len: i32;

    entry: linux_dirent64*;

    home_dir: char* = null

    while {
        if(iter.fd_current_dir < 0){
            if(iter.remaining_directories.size()==0){
                return false;
            }
            iter.current_dir.clear();
            
            dir := iter.remaining_directories.get(0);
            iter.remaining_directories.remove(0);
            
            Assert(dir.size() != 0)

            if equal_start("~/",dir.sliced())  {
                if !home_dir {
                    home_dir = FindEnvironmentVar("HOME")
                    iter.current_dir.append(home_dir)
                    iter.current_dir.append("/")
                }
                iter.current_dir.append(substring(dir.sliced(), 2));
            } else {
                iter.current_dir.append(dir.sliced());
            }

            fd := open(iter.current_dir.data(), O_DIRECTORY)

            if(fd < 0){
                log("Error in 'DitectoryIteratorNext': open(\"",iter.current_dir,"\"), ", name_of_error(fd))
                continue;
            }
            iter.fd_current_dir = fd
        }
        
        if iter.head >= iter.bytes_in_buffer {
            iter.bytes_in_buffer = getdents64(iter.fd_current_dir, iter.buffer.ptr, iter.buffer.len)
            iter.head = 0
            if iter.bytes_in_buffer <= 0 {
                if iter.bytes_in_buffer < 0 {
                    log("getdents64 failed")
                }
                close(iter.fd_current_dir)
                iter.fd_current_dir = -1
                continue // end of directory
            }
        }

        entry = cast<linux_dirent64*>iter.buffer.ptr + iter.head
        iter.head += entry.d_reclen

        file_name = entry.d_name.ptr
        file_name_len = strlen(entry.d_name.ptr)

        
        if equal(file_name, ".") || equal(file_name, "..")
            continue
        if file_name_len == 0
            continue // impossible?

        break;
    }
    
    iter.item.name.clear()
    
    if iter.current_dir.size() {
        iter.item.name.append(iter.current_dir.sliced())
        iter.item.name.append("/")
        iter.item.name.append(file_name, file_name_len)
    } else {
        iter.item.name.append(file_name, file_name_len)
    }

    // log(file_name)

    safe: char[48]
    file_info: stat;
    res := stat(iter.item.name.sliced().ptr, &file_info)

    // std_print_any(&file_info, true)

    // safe_ptr: char* = cast<char*>&safe;
    // for 0..32 {
    //     log(cast<i32>safe_ptr[nr*4]," ",cast<i32>safe_ptr[nr*4+1]," ",cast<i32>safe_ptr[nr*4+2]," ",cast<i32>safe_ptr[nr*4+3])
    // }

    if res >= 0 {
        iter.item.file_size = file_info.st_size
        iter.item.last_write_time = file_info.st_mtime * 1000_000_000u + file_info.st_mtime_nsec
    }
    
    iter.item.is_directory = (entry.d_type & cast<u8>DT_DIR) != 0
    if(iter.item.is_directory){
        iter.remaining_directories.add(iter.item.name.copy());
    }

    #else
    incomplete
    #endif

    if out_item ;
        *out_item = &iter.item

    return true;
}
fn DirectoryIteratorSkip(iterator: DirIterator) {
    if iterator == DirIterator.INVALID
        return
    index := IteratorToInternal(iterator)
    iter := _directory_iterators.get(index)
    
    if iter.remaining_directories.size()
        iter.remaining_directories.pop()
}
fn GetWorkingDirectory() -> StringBuilder {
    #if OS_WINDODWS
    #elif OS_LINUX
    cwd: StringBuilder
    cwd.resize(255)
    cwd_err := cast<i64>getcwd(cwd.data(), cwd.size()-1)
    if cwd_err < 0 {
        log("Error in 'GetWorkingDirectory': getcwd, ",name_of_error(cwd_err))
        cwd.cleanup()
        return cwd
    }
    cwd.resize(strlen(cwd.ptr))
    return cwd
    #endif
}
// converts path to absolute path
fn AbsolutePath(path: char[]) -> StringBuilder {
    #if OS_WINDODWS
    #elif OS_LINUX
    b: StringBuilder
    if equal_start("~/", path) {
        home_dir := FindEnvironmentVar("HOME")
        b.append(home_dir)
        b.append(substring(path,1)) // skip ~, keep /
    } else if equal_start("/", path) {
        b.append(path)
    } else if equal_start("./", path) {
        cwd := GetWorkingDirectory()
        cwd.append(substring(path, 1)) // skip ., keep /
        return cwd
    } else {
        cwd := GetWorkingDirectory()
        b.append("/");
        b.append(path);
        return cwd
    }
    return b
    #endif
}

// returns absolute path to the found file, empty string if nothing was found
// if multiple files match then any one can be picked (depends on DirectoryIterator)
// if recursive then the specified directories (CWD, PATH, dirs) will be searched recursively (skipping those that start with '.')
// if search_env_path, additionally search directories in PATH
fn FindFile(path: char[], search_env_path: bool = false, recursive: bool = false) -> StringBuilder {
    // TODO: Rename function to FindFileInEnvPath?
    // TODO: Perhaps have another function FindFile(path, directories_to_search)?
    #if OS_WINDOWS
    #elif OS_LINUX
    result: StringBuilder
    if access(path.ptr, F_OK) == 0 {
        result.append(path)
        return result
    }

    dirs: Array<StringBuilder>
    defer {
        for dirs.sliced()
            it.cleanup()
        dirs.cleanup()
    }
    if search_env_path {
        env_path := FindEnvironmentVar("PATH")

        if env_path {
            extra_paths := split(":",env_path)
            for extra_paths.sliced_unsafe() {
                // log(it)
                s: StringBuilder
                s.append(AbsolutePath(it))
                dirs.add(s)
            }
        }
    }

    cwd := Slice<char> {Allocate(256), 256}
    defer Free(cwd.ptr)
    cwd_err := cast<i64>getcwd(cwd.ptr, cwd.len-1)
    if cwd_err < 0 {
        log("Error in 'FindFile': getcwd, ",name_of_error(cwd_err))
        return result
    }
    cwd.len = strlen(cwd.ptr)

    root: StringBuilder
    defer { root.cleanup() }
    slash_pos := find("/", path, reverse = true)
    // log("pos ",slash_pos)
    file_name: StringBuilder
    if(slash_pos != -1) {
        file_name.append(substring(path, slash_pos))
    } else {
        file_name.append("/")
        file_name.append(path)
    }

    root.append(cwd)
    if slash_pos != -1 {
        root.append("/")
        root.append(substring(path, 0, slash_pos))
    }

    // remove duplicates, TODO: the way we check duplicates is a little flawed, look into it
    root_exists := false
    for dirs.sliced() {
        // log(it, " == ", root)
        if !recursive {
            if it == root {
                root_exists = true
                break
            }
        } else {
            if equal_start(it.sliced(), root.sliced()) {
                root_exists = true
                break
            } else if equal_start(root.sliced(), it.sliced()) && recursive {
                // swap
                dirs.ptr[nr].cleanup()
                dirs.ptr[nr] = root
                root.cleanup(false)
                root_exists = true
                break
            }
        }
    }
    if !root_exists {
        dirs.add(root)
        root.cleanup(false)
    }

    // for dirs.sliced() {
    //     log(it)
    // }

    // log("root ",root, ", file ",file_name)
    for dirs.sliced_unsafe() {
        iter := DirectoryIteratorCreate(it.sliced())
        defer DirectoryIteratorDestroy(iter)
        item: DirIteratorItem*;
        while DirectoryIteratorNext(iter, &item) {
            if item.is_directory {
                if find("/.",item.name.sliced()) != -1 || !recursive
                    DirectoryIteratorSkip(iter)
            }
            // log(item.name, " == ", file_name)
            yes := equal_end(file_name.sliced(), item.name.sliced())
            if yes {
                // log("found ",item.name)
                result.append(item.name)
                return result
            }
        }
    }

    return result
    #endif
}