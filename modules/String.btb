#import "Memory"
#import "Logger"
#import "Array"

#macro LN printc('L'); printc('N'); std_print(cast<i64>#line); std_print('\n')


// heap allocated for now
// null terminated
struct StringBuilder {
    // I was gonna say, the order ptr, len, max
    // allows you to cast String to char[] but that's wrong
    // because len in slice is 8 bytes while being 4 bytes here.
    ptr: char*; // null terminated
    len: i32;
    max: i32; // does not include \0

    fn cleanup(free_stuff: bool = true) {
        if !free_stuff {
            ptr = null
            len = 0
            max = 0
        } else {
            reserve(0)
        }
    }

    fn sliced() -> Slice<char> {
        return Slice<char>{ptr, len};
    }
    fn size() -> i32 { return len }
    fn data() -> char* { return ptr }
    fn get(index: i32) -> char { 
        // TODO: Bounds check
        return ptr[index]
    }
    fn clear() {
        len = 0;
        if ptr {
            *ptr = '\0'
        }
    }
    fn append(value: i64) {
        if len + 20 > max {
            reserve(len + 20);
        }
        len += swrite_unsafe(ptr + len, value);
    }
    fn append(value: char) {
        if len + 1u > max {
            if !reserve(len + 5)
                return;
        }
        ptr[len] = value
        len++
        ptr[len] = '\0'
    }
    fn append(value: bool) {
        if value {
            append("true")
        } else {
            append("false")
        }
    }
    fn append(value: u64) {
        if len + 20 > max {
            reserve(len + 20);
        }
        len += swrite_unsafe(ptr + len, value);
    }
    fn append(value: f32) {
        if len + 25 > max {
            reserve(len + 25);
        }
        len += swrite_unsafe(ptr + len, value);
    }
    fn append(str: char[]) {
        if str.len == 0
            return;
        if len + str.len > max {
            if !reserve(str.len + 10 + max * 2) {
                return;
            }
        }
        memcpy(ptr + len, str.ptr, str.len);
        len += str.len;
        ptr[len] = '\0';
    }
    fn append(str: char*, size: i32) {
        if len + size > max {
            if !reserve(size + max * 2) {
                return;
            }
        }
        memcpy(ptr + len, str, size);
        len += size;
        ptr[len] = '\0';
    }
    fn append(str: char*) {
        append(str, strlen(str))
    }
    fn append(str: StringBuilder) {
        append(str.sliced())
    }
    fn append_hex<T>(p: T*) {
        bytes: u8* = cast<u8*>cast<void*>p
        l: u32 = sizeof T
        for 0..l {
            hex0 := bytes[nr] & cast<u8>0x0F
            hex1 := bytes[nr] >> cast<u8>4
            if hex1 < 10u   append(cast<char>('0' + hex1))
            else            append(cast<char>('a' + hex1 - 10))
            if hex0 < 10u   append(cast<char>('0' + hex0))
            else            append(cast<char>('a' + hex0 - 10))
        }
    }
    fn append_hex(p: void*, l: u32) {
        bytes: u8* = cast<u8*>cast<void*>p
        for 0..l {
            hex0 := bytes[nr] & cast<u8>0x0F
            hex1 := bytes[nr] >> cast<u8>4
            if hex1 < 10u   append('0' + hex1)
            else            append('a' + hex1 - 10)
            if hex0 < 10u   append('0' + hex0)
            else            append('a' + hex0 - 10)
        }
    }

    fn insert(pos: i32, chr: char) {
        if len + 1 > max {
            if !reserve(1 + max * 2) {
                return;
            }
        }
        memcpy(ptr + pos + 1, ptr + pos, len - pos);
        len += 1;
        ptr[pos] = chr
        ptr[len] = '\0';
    }
    fn removeAt(pos: i32) {
        if len-pos < 0 {
            memcpy(ptr + pos, ptr + pos + 1, len - (pos + 1));
        }
        len -= 1;
        ptr[len] = '\0';
    }
    
    fn resize(newLen: i32) -> bool {
        if newLen > max {
            if !reserve(newLen)
                return false;
        }
        len = newLen;
        return true;
    }
    // TODO: Some useful functions
    fn reserve(newMax: i32) -> bool {
        // log("newMax",newMax)
        if(newMax==0){
            // log("oh")
            if(max!=0){
                Free(ptr, max + 1);
            }
            ptr = null;
            max = 0;
            len = 0;
            return true;
        }
        // log("what",cast<u64>ptr)
        if(!ptr){
            // log("huh")
            ptr = Allocate(newMax + 1);
            *ptr = '\0';
            // log("allocSize",newMax * sizeof T)
            // log("ptr",ptr)
            // Assert(ptr);
            // initialization of elements is done when adding them
            if(!ptr)
                return false;
            max = newMax;
            return true;
        } else {
            newPtr: char* = Reallocate(newMax + 1, ptr, max + 1);
            // Assert(newPtr);
            if(!newPtr)
                return false;
            ptr = newPtr;
            max = newMax;
            if(len > newMax){
                len = newMax;
            }
            return true;
        }
        return false;
    }
    fn copy() -> StringBuilder {
        s: StringBuilder
        s.append(sliced())
        return s
    }
}
operator cast(b: StringBuilder) -> Slice<char> {
    return b.sliced()
}
operator [](b: StringBuilder, index: i32) -> char {
    return b.get(index)
}
// #import "String"
// #import "Logger"

// a0 = "my"
// a1 = "stuff"

// str: String;
// defer str.cleanup();

// str.append(a0)
// str.append(a1)
// str.append(a0)

// log(str.sliced())

// #import "OS"

fn sliced(s: char*) -> char[] {
    return Slice<char>{s, strlen(s)}
}

fn @hide std_print(t: StringBuilder){
    std_print(t.sliced())
}

operator ==(a: StringBuilder, b: StringBuilder) -> bool {
    return a.sliced() == b.sliced()
}
operator ==(a: StringBuilder, b: Slice<char>) -> bool {
    return a.sliced() == b
}
operator ==(a: Slice<char>, b: Slice<char>) -> bool {
    if a.len != b.len  return false;
    for a
        if it != b.ptr[nr]
            return false;
    return true;
}
// TODO: Inline
operator !=(a: Slice<char>, b: Slice<char>) -> bool {
    return !(a == b);
}

// fn @hide swrite_hex_unsafe(ptr: void*, len: void*) -> u32 {
    
// }

// Returns the amount of written bytes
// Will put a null termination at the end of the written bytes
fn @hide swrite_unsafe(buffer: char*, slice: char[]) -> i32 {
    // LN;
    memcpy(buffer, slice.ptr, slice.len);
    buffer[slice.len] = '\0';
    return slice.len;
}
// Returns the amount of written bytes
// Will put a null termination at the end of the written bytes
fn @hide swrite_unsafe(buffer: char*, cstr: char*) -> i32 {
    // LN;
    len = strlen(cstr);
    memcpy(buffer, cstr, len);
    buffer[len] = '\0';
    return len;
}
// Returns the amount of written bytes
// Will put a null termination at the end of the written bytes
fn @hide swrite_unsafe(buffer: char*, value: i64) -> i32 {
    // LN
    start := buffer;
    if value == 0 {
        buffer[0] = '0';
        buffer[1] = '\0';
        return 1;
    }
    if value < 0 {
        value = -value;
        *buffer = '-';
        buffer++;
    }
    // LN
    str: char[21];
    used := 20;
    while value > 0 && used > 0 {
        num := value % 10;
        value = value / 10;
        str.ptr[used] = num + '0';
        used--;
    }
    // LN
    str.ptr += used + 1;
    str.len -= used + 1;

    memcpy(buffer, str.ptr, str.len);
    buffer += str.len;
    *buffer = '\0'; // not include in written bytes

    return cast<u64>(buffer - start);
}
fn @hide swrite_unsafe(buffer: char*, value: u64) -> u32 {
    start := buffer;
    if value == 0 {
        buffer[0] = '0';
        buffer[1] = '\0';
        return 1;
    }
    str: char[21];
    used := 20;
    while value > 0u && used >= 0 {
        num := value % 10u;
        value = value / 10u;
        str.ptr[used] = num + '0';
        used--;
    }
    str.ptr += used + 1;
    str.len -= used + 1;

    memcpy(buffer, str.ptr, str.len);
    buffer += str.len;
    *buffer = '\0'; // not include in written bytes

    return cast<u64>(buffer - start);
}
// Returns the amount of written bytes
// Will put a null termination at the end of the written bytes
fn @hide swrite_unsafe(buffer: char*, t: f32) -> i32 {
    // LN;
    start := buffer;
    bits: u32 = *cast<u32*>cast<void*>&t;

    sign := (bits >> 31u) & 1u;
    exp := (bits >> 23u) & cast<u32>0xFF
    mantissa: u64 = cast<u64>0x80_0000 | (cast<u64>bits & cast<u64>0x7FFFFF)

    if sign {
        *buffer = '-';
        buffer++;
    }

    // log("Bro")

    intPart: u64 = 0;
    decimalBits: i32 = 23 - (exp-127);
    if decimalBits < 1 {
        intPart = (mantissa) << (0-decimalBits);

        // log("pl");
        if intPart == 0 {
            *buffer = '0';
            buffer++;
        } else {
            // we don't use swrite_unsafe because it uses
            // i64 but we need u64 for the extra large integers.
            str: char[23];
            used := 22;
            while intPart > 0u && used > 0 {
                digit: u8 = intPart % 10u;
                // log("i",intPart);
                // log("d",digit);
                str.ptr[used] = digit + '0';
                used--;
                intPart = intPart / 10u;
            }
            str.ptr += used + 1;
            str.len -= used + 1;
            // prints(str);
            
            memcpy(buffer, str.ptr, str.len);
            buffer += str.len;
            log("o");
        }

        // buffer += swrite_unsafe(buffer, intPart);
        *buffer = '.';
        buffer++;
        *buffer = '0';
        buffer++;
    } else {
        // log("ya");

        // LN
        if exp > 126u
            intPart = (mantissa) >> decimalBits;
        // LN;
        // log(intPart)
        { 
            buffer += swrite_unsafe(buffer, cast<i64>intPart);
        }
        *buffer = '.';
        buffer++;
        // LN
        decimals: char[24];

        acc: u64 = 0;
        mul: u64 = 1;
        precision := 19; // digits u64 can contain (18446744073709551615)
        minBits := decimalBits - precision;
        if minBits < 0
            minBits = 0;
        for @rev minBits..decimalBits {
            mul *= 5u;
            acc = acc*10u
            if nr < 24 {
                bit := cast<u64>1 & (mantissa >> nr)
                if bit {
                    acc += mul;
                }
            }
        }
        // LN
        if acc == 0 {
            *buffer = '0';
            buffer++;
        }
        blank := true;
        lastZero := 0;
        limit := precision;
        if decimalBits < precision;
            limit = decimalBits;
            // LN
        for @rev 0..limit {
            digit := acc % 10u;
            acc = acc / 10u;
            if !blank || digit != 0 {
                decimals.ptr[nr] = digit + '0';
                if blank
                    lastZero = nr+1
                blank = false;
            }
        }
        // LN
        decimals.len = lastZero;
        memcpy(buffer, decimals.ptr, decimals.len);
        buffer += decimals.len;
        // LN
    }
    *buffer = '\0'; // not include in written bytes
    return cast<i64>(buffer - start);
}


// TODO: swrite needs to be tested, mainly with baseOffset
// returns the amount of written bytes
// returns 0 if buffer was to small to fit the number
// baseOffset is optional
// the written amount will be added onto baseOffset
// will put a null termination at the end of the written bytes if 
// space is available
// fn @hide swrite(buffer: Slice<char>*, value: i64, baseOffset: u32* = null) -> u32 {
//     // optimise by using a log10 function, unless they are slow, to know how many characters you need.
//     offset = 0;
//     if baseOffset
//         offset = *baseOffset;
//     if value == 0 {
//         if buffer.len - offset < 1 {
//             return 0;
//         }
//         buffer.ptr[offset++] = '0';
//         if buffer.len - offset > 0 {
//             buffer.ptr[offset] = '\0';
//         }
//         if baseOffset;
//             *baseOffset = offset;
//         return 1;
//     }
//     signed = false;
//     if value < 0 {
//         signed = true;
//         value = -value;
//     }
//     str: char[21];
//     used = 20;
//     while value > 0 && used > 0 {
//         num = value % 10;
//         str.ptr[used] = num + '0';
//         // log("a ",num, used)
//         used--;
        
//         value = value / 10;
//     }
//     if signed {
//         str.ptr[used] = '-';
//         used--;
//     }
//     str.ptr += used + 1;
//     str.len -= used + 1;
//     // log(strstr.len)
//     if str.len > buffer.len - offset {
//         return 0;
//     }
//     memcpy(buffer.ptr + offset, str.ptr, str.len);
//     offset += str.len;
//     if 1 > buffer.len - offset {
//         buffer.ptr[offset] = '\0';
//     }

//     if baseOffset {
//         *baseOffset = offset;
//     }
//     // log(written);
//     return str.len;
// }


fn parse_i64(slice: Slice<char>, read_chars: u32* = null) -> i64 {
    // TODO: Parse white space?
    // TODO: Parse negative number
    result: i64;
    i: u32 = 0;
    while i < slice.len {
        chr := slice.ptr[i];
        if chr >= '0' && chr <= '9' {
            result = result * 10 + chr - '0';
        } else {
            break;
        }
        i++;
    }
    if read_chars {
        *read_chars = i;
    }
    return result;
}
// function assumes the text is a correct hexidecimal string
// even length, characters which are digits or A-F
fn parse_hex(text: Slice<char>, data: Slice<u8>*) {
    Assert(text.len/2u == data.len)
    for 0..text.len/2u {
        tmp: u8 = 0
        hex0 := text.ptr[2*nr]
        hex1 := text.ptr[2*nr+1]
        if hex0 <= '9' {
            tmp = hex0 - '0'
        } else if hex0 >= 'a' && hex0 <= 'f' {
            tmp = hex0 - 'a' + 10
        } else if hex0 >= 'A' && hex0 <= 'F' {
            tmp = hex0 - 'A' + 10
        }
        tmp = tmp << cast<u8>4
        if hex1 <= '9' {
            tmp |= hex1 - '0'
        } else if hex1 >= 'a' && hex1 <= 'f' {
            tmp |= hex1 - 'a' + 10
        } else if hex1 >= 'A' && hex1 <= 'F' {
            tmp |= hex1 - 'A' + 10
        }
        data.ptr[nr] = tmp
    }
}

#import "Logger"

// TODO:: The debugger can't handle macros.
//   Add it to DWARF or use fewer macros.
#macro SLICE_OVERLOADS(FUNC, A0, A1, RET)
fn FUNC(A0: char*, A1: char*) -> RET {
    return FUNC(Slice<char>{A0,strlen(A0)}, Slice<char>{A1,strlen(A1)})
}
fn FUNC(A0: char[], A1: char*) -> RET {
    return FUNC(A0, Slice<char>{A1,strlen(A1)})
}
fn FUNC(A0: char*, A1: char[]) -> RET {
    return FUNC(Slice<char>{A0,strlen(A0)}, A1)
}
#endmacro
SLICE_OVERLOADS(equal, a, b, bool)
fn equal(a: char[], b: char[]) -> bool {
    if a.len != b.len
        return false
    for a {
        if it != b.ptr[nr]
            return false
    }
    return true
}
SLICE_OVERLOADS(equal_start, pattern, text, bool)
fn equal_start(pattern: char[], text: char[]) -> bool {
    if text.len < pattern.len || pattern.len == 0
        return false
    for pattern {
        if it != text.ptr[nr]
            return false
    }
    return true
}
SLICE_OVERLOADS(equal_end, pattern, text, bool)
fn equal_end(pattern: char[], text: char[]) -> bool {
    if text.len < pattern.len || pattern.len == 0
        return false
    for @rev pattern {
        if it != text.ptr[text.len + nr - pattern.len]
            return false
    }
    return true
}
// returns -1 if not found
// returns the index to the first character of pattern found in the text.
// if not reverse, then first match is returned, otherwise, last match is returned
SLICE_OVERLOADS(find, pattern, text, i32)
fn find(pattern: char[], text: char[], reverse: bool = false) -> i32 {
    if text.len < pattern.len || pattern.len == 0
        return -1;
    if !reverse {
        correct := 0;
        for text {
            if it == pattern.ptr[correct] {
                correct++;
                if correct == pattern.len
                    return nr - pattern.len + 1
            } else {
                correct = 0;
            }
        }
    } else {
        correct := pattern.len-1;
        for @reverse text {
            if it == pattern.ptr[correct] {
                correct--;
                if correct == -1
                    return nr
            } else {
                correct = pattern.len-1;
            }
        }
    }
    return -1;
}
SLICE_OVERLOADS(split, pattern, text, Array<char[]>)
// the returned array contains substrings referencing memory in 'text'
// if 'text' is freed than the array will point to invalid memory
fn split(pattern: char[], text: char[]) -> Array<char[]> {
    arr: Array<char[]>;
    if pattern.len == 0
        return arr

    correct := 0
    split_start := 0
    for text {
        if it == pattern[correct] {
            correct++
            if correct == pattern.len {
                arr.add(Slice<char>{text.ptr + split_start, nr + 1 - pattern.len  - split_start})
                correct = 0;
                split_start = nr + 1
            }
        } else {
            correct = 0
            if nr == text.len - 1 {
                arr.add(Slice<char>{text.ptr + split_start, 1 + nr - split_start})
                break
            }
        }
    }

    return arr
}
fn substring(text: char*, start: i32, end: i32 = -1) -> char[] {
    return substring(Slice<char>{text,strlen(text)}, start, end)
}
// end is exclusive
fn substring(text: char[], start: i32, end: i32 = -1) -> char[] {
    if start >= text.len
        return Slice<char>{}
    if end > text.len
        end = text.len
    if start < 0
        start = 0
    if end < 0
        return Slice<char>{text.ptr + start, text.len - start}
    return Slice<char>{text.ptr + start, end - start}
}

// Look at Utility.cpp
// fn FormatTime() {
    
// }

fn printData<T>(t: T*) {
    at := 0;
    while at < sizeof T {
        byte: u8 = *(cast<u8*>cast<void*>t + at);
        if at % 8 == 0 {
            std_print('\n',at,": ");
        }
        std_print(byte, ' ')
        at++
    }
}