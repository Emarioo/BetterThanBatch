// #import "Logger"

/* Forced by the compiler
struct @hide Slice<T> {
    ptr: T*;
    len: u64;
}
struct @hide Range {
    beg: i32;
    end: i32;
}
*/

// struct Memory<T> {
//     ptr: T*;
//     max: u64;
//     used: u64;
//     // fn resize()
// }


// Use native functions instead
// fn memset(ptr: void*, len: u64, value: u8 = 0) {
//     for 0..len {
//         *(cast<u8*>ptr + nr) = value;
//     }
// }
// fn memcmp(ptrA: void*, ptrB: void*, len: u64) -> i32 {
//     for 0..len {
//         if *(cast<u8*>ptrA + nr) != *(cast<u8*>ptrB + nr) {
//             return *(cast<u8*>ptrA + nr) - *(cast<u8*>ptrB + nr);
//         }
//     }
//     return 0;
// }
// fn equal(a: char[], b: char[]) -> i32 {
//     if a.len != b.len
//         return false
//     return !memcmp(a.ptr, b.ptr, a.len);
// }
// fn memcpy(dst: void*, src: void*, len: u64) {
//     for 0..len {
//         *(cast<u8*>dst + nr) = *(cast<u8*>src + nr);
//     }
// }

#import "Logger"
// Test: matchEnd("__add.cpp__","++.cpp++");
fn matchEnd(str: char[], match: char[]) -> bool {
    // log("lens",str.len, match.len)
    if str.len < match.len
        return false
    for @reverse match {
        // log("nr:",nr)
        // thing = match.ptr[nr];
        // log("i:",nr + str.len - match.len)
        chr = str.ptr[nr + str.len - match.len];
        // log("i2:",nr + str.len - match.len)
        if it != chr {
            // log("ret1")
            return false
        }
        // log("cont")
    }
    // log("ret2")
    return true
}

fn printData<T>(t: T*) {
    at = 0;
    while at < sizeof T {
        byte: u8 = *(cast<u8*>cast<void*>t + at);
        if at % 8 == 0 {
            print('\n',at,": ");
        }
        print(byte, ' ')
        at++
    }
}