/*
    This is a file/module which contains functions that allows
    you to interact with the operating system. Programs are 
    useless without these functions.
*/
// fn @native prints(str: char[]) ;

#ifdef LINK_BYTECODE
#define LINK_TYPE @native
#else
#ifdef OS_UNIX
#define LINK_TYPE @import @unixcall
#else
#define LINK_TYPE @import @stdcall
#endif
#endif

// #define Assert(expression) ((expression) ? true : (fprintf(stderr,"[Assert] %s (%s:%u)\n",#expression,__FILE__,__LINE__), *((char*)0) = 0))
#define Assert(expression)

// TODO: Move intrinsics elsewhere
// len is in bytes
fn @intrinsic memcpy(dst: void*, src: void*, len: u64);
fn @intrinsic memzero(dst: void*, len: u64);
fn @intrinsic strlen(ptr: char*) -> u32;
// returns time stamp counter and IA32_TSC_AUX 
fn @intrinsic rdtsc() -> u64;
// fn @intrinsic rdtscp() -> u64, u32;
fn @intrinsic compare_swap(ptr: i32*, old: i32, new: i32) -> bool;
fn @intrinsic atomic_add(ptr: i32*, value: i32);
// TODO: atomic_add64?

// fn @native printi(num: i64) ;
// fn @native printd(num: f32) ;
// fn @native printc(chr: char) ;

fn LINK_TYPE Allocate(size: u64) -> void*;
fn LINK_TYPE Reallocate(ptr: void*, oldSize: u64, newSize: u64) -> void* ;
fn LINK_TYPE Free(ptr: void*, size: u64) ;


// // using u64 as File does not work since functions are evaluated
// // first and then using. Using won't be applied to functions.
// // A macro is used instead,or now.
// // File handle
// #define File u64
// enum FileFlag {
//     FILE_NO_FLAG=0,
//     FILE_ONLY_READ=1,
//     FILE_CAN_CREATE=2,
//     FILE_ALWAYS_CREATE=4,
// }
// returns file handle and file size
// fn LINK_TYPE FileOpen(path: Slice<char>*, readOnly: bool, outFileSize: u64* = null) -> File;
// // returns read bytes
// fn LINK_TYPE FileRead(file: File, buffer: void*, readBytes: u64) -> u64;
// // returns written bytes
// fn LINK_TYPE FileWrite(file: File, buffer: void*, writeBytes: u64) -> u64;
// fn LINK_TYPE FileClose(file: File);

// // The returned string is heap allocated in the interpreter.
// // This allocation is freed when the interpreter finishes.
// // TODO: You may want to change this so that you give the function a
// //   StringBuffer or StringBuilder and it puts the CWD in there while
// //   still returning a slice. Perhaps the StringBuilder defaults to null
// //   and if not provided it is heap allocated, otherwise allocated in StringBuilder.
fn @native CurrentWorkingDirectory() -> char[]; // should it be const?
fn LINK_TYPE StartMeasure() -> u64;
fn LINK_TYPE StopMeasure(timePoint: u64) -> f32; // TODO: Use f64 (double) when implemented
fn LINK_TYPE DiffMeasure(endSubStart: u64) -> f32; // TODO: Use f64 (double) when implemented
fn LINK_TYPE NativeSleep(seconds: f32);

fn @import CmdLineArgs() -> Slice<Slice<char>>*; // const?

// fn LINK_TYPE DirectoryIteratorCreate(rootPath: Slice<char>*) -> DirectoryIterator*;
// fn LINK_TYPE DirectoryIteratorDestroy(iterator: DirectoryIterator*);
// fn LINK_TYPE DirectoryIteratorNext(iterator: DirectoryIterator*) -> DirectoryIteratorData*;
// fn LINK_TYPE DirectoryIteratorSkip(iterator: DirectoryIterator*);

fn @import GetClockSpeed() -> u64;

fn @import ExecuteCommand(path: Slice<char>*, asynchronous: bool = false, exitCode: i32* = null) -> bool;

struct DirectoryIteratorData {
    name: char[]; // Allocated by interpreter; can't be String because of that. The ptr should be const (char* const NOT const char*)
    fileSize: u64;
    lastWriteSeconds: f32;
    isDirectory: bool;
}
struct DirectoryIterator {
    _handle: u64;
    rootPath: char[]; // allocated by interpreter, should be char* const
    result: DirectoryIteratorData;

    fn next() -> DirectoryIteratorData* {
        return DirectoryIteratorNext(this);
    }
    fn skip() {
        DirectoryIteratorSkip(this);
    }
}