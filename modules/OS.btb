/*
    This is a file/module which contains functions that allows
    you to interact with the operating system. Programs are 
    useless without these functions.

    TODO: The implementation is defined in NativeLayer.cpp.
      We will deprecate NativeLayer and just write the implementation in .btb files.
      Either all versions in OS.btb or in separate Win32.btb, Unix.btb.


*/

#import "Memory"
#import "File"
#import "Logger"

// #if LINKER_MSVC
//     #load "bin/NativeLayer.lib" as native_layer
// #else
//     #load "bin/NativeLayer_gcc.lib" as native_layer
// #endif

#if LINK_BYTECODE
    #macro LINK_TYPE @native
#elif OS_WINDOWS
    #macro LINK_TYPE @import(native_layer) @stdcall
#elif OS_LINUX
    #macro LINK_TYPE @import(native_layer) @unixcall
#endif


// #macro Assert(expression) ((expression) ? true : (fprintf(stderr,"[Assert] %s (%s:%u)\n",#expression,__FILE__,__LINE__), *((char*)0) = 0))
#macro Assert(expression) #endmacro

// fn LINK_TYPE StartMeasure() -> u64;
// fn LINK_TYPE StopMeasure(timePoint: u64) -> f32; // TODO: Use f64 (double) when implemented
// fn LINK_TYPE DiffMeasure(endSubStart: u64) -> f32; // TODO: Use f64 (double) when implemented
// fn LINK_TYPE NativeSleep(seconds: f32);


// fn LINK_TYPE GetClockSpeed() -> u64;

// fn LINK_TYPE ExecuteCommand(path: Slice<char>*, asynchronous: bool = false, exitCode: i32* = null) -> bool;

// Returns false if anything failed, NOT if the program you called
// failed. Check 'exit_code' for that.
// 'asynchronous' will run the command without waiting for status code
fn ExecuteCommand(cmd: Slice<char>, exit_code: i32*, asynchronous: bool = false) -> bool {

}


fn set_cursor(x: u32, y: u32) {
    std_print("\e[",(x),";",(y),"H")
}
fn move_cursor(x: i32, y: i32) {
    if y > 0 {
        std_print("\e[",y,"A");
    } else if y < 0 {
        std_print("\e[",-y,"B");
    }
    if x > 0 {
        std_print("\e[",x,"C");
    } else if x < 0 {
        std_print("\e[",-x,"D");
    }
}