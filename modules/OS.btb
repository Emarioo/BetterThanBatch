/*
    This is a file/module which contains functions that allows
    you to interact with the operating system. Programs are 
    useless without these functions.
*/
// fn @native prints(str: char[]) ;

#ifdef LINK_BYTECODE
#define LINK_TYPE @native
#else
#define LINK_TYPE @import
#endif

// intrinsics?
// len is in bytes
fn @intrinsic memcpy(dst: void*, src: void*, len: u64);
fn @intrinsic memzero(dst: void*, len: u64);
// returns time stamp counter and IA32_TSC_AUX 
fn @intrinsic rdtsc() -> u64;
// fn @intrinsic rdtscp() -> u64, u32;
fn @intrinsic compare_swap(ptr: i32*, old: i32, new: i32) -> bool;

// Functions below are not supported in x64 converter
// #ifndef X64
// fn @native printi(num: i64) ;
// fn @native printd(num: f32) ;
// fn @native printc(chr: char) ;

fn LINK_TYPE Allocate(size: u64) -> void* ;
fn LINK_TYPE Reallocate(ptr: void*, oldSize: u64, newSize: u64) -> void* ;
fn LINK_TYPE Free(ptr: void*, size: u64) ;


// // using u64 as File does not work since functions are evaluated
// // first and then using. Using won't be applied to functions.
// // A macro is used instead,or now.
// // File handle
#define File u64
enum FileFlag {
    FILE_NO_FLAG=0,
    FILE_ONLY_READ=1,
    FILE_CAN_CREATE=2,
    FILE_WILL_CREATE=4,
}
// returns file handle and file size
fn @native FileOpen(path: Slice<char>, flags: FileFlag) -> File, u64;
// returns read bytes
fn @native FileRead(file: File, buffer: void*, readBytes: u64) -> u64 ;
// returns written bytes
fn @native FileWrite(file: File, buffer: void*, writeBytes: u64) -> u64 ;
fn @native FileClose(file: File) ;

// // The returned string is heap allocated in the interpreter.
// // This allocation is freed when the interpreter finishes.
// // TODO: You may want to change this so that you give the function a
// //   StringBuffer or StringBuilder and it puts the CWD in there while
// //   still returning a slice. Perhaps the StringBuilder defaults to null
// //   and if not provided it is heap allocated, otherwise allocated in StringBuilder.
fn @native CurrentWorkingDirectory() -> char[]; // should it be const?
fn @native StartMeasure() -> u64;
fn @native StopMeasure(timePoint: u64) -> f32; // TODO: Use f64 (double) when implemented

fn @import CmdLineArgs() -> Slice<Slice<char>>*; // const?

// fn @import DirectoryIteratorCreate(path: char*, pathlen: i32) -> u64;
// fn @import DirectoryIteratorNext(iterator: u64, result: DirectoryIteratorData*) -> bool;
// fn @import DirectoryIteratorSkip(iterator: u64);
// fn @import DirectoryIteratorDestroy(iterator: u64, dataToDestroy: DirectoryIteratorData*);

fn LINK_TYPE DirectoryIteratorCreate(rootPath: Slice<char>*) -> DirectoryIterator*;
fn LINK_TYPE DirectoryIteratorDestroy(iterator: DirectoryIterator*);
fn LINK_TYPE DirectoryIteratorNext(iterator: DirectoryIterator*) -> DirectoryIteratorData*;
fn LINK_TYPE DirectoryIteratorSkip(iterator: DirectoryIterator*);

struct DirectoryIteratorData {
    name: char[]; // allocated by interpreter, the ptr should be const (char* const NOT const char*)
    fileSize: u64;
    lastWriteSeconds: f32;
    isDirectory: bool;
}
// #import "Logger"
struct DirectoryIterator {
    _handle: u64;
    rootPath: char[]; // allocated by interpreter, should be char* const
    result: DirectoryIteratorData;

    fn next() -> DirectoryIteratorData* {
        // log("yeah")
        // DirectoryIteratorNext(null);
        // return null;
        return DirectoryIteratorNext(this);
    }
    fn skip() {
        DirectoryIteratorSkip(this);
    }
}
// #else

// struct Thread {
//     handle: i64 = 0;
//     id: u32 = 0;
// }
// fn ThreadCreate(func: fn_ref, param: void*) -> Thread {
//     threadId: u32 = 0;
//     handle = CreateThread(null, 0, func, param, null, &threadId);
//     return Thread{handle, threadId};
// }
// fn ThreadDestroy(thread: Thread) {
//     CloseHandle(thread.handle);
// }
// fn ThreadJoin(thread: Thread) {
//     WaitForSingleObject(thread.handle, 0xFFFFFFFF);
// }
// fn @dllimport CreateThread(
//   /* [in, optional]  LPSECURITY_ATTRIBUTES   */ lpThreadAttributes: void*,
//   /* [in]            SIZE_T                  */ dwStackSize: u64,
//   /* [in]            LPTHREAD_START_ROUTINE  */ lpStartAddress: fn_ref,
//   /* [in, optional]  __drv_aliasesMem LPVOID */ lpParameter: void*,
//   /* [in]            DWORD                   */ dwCreationFlags: void*,
//   /* [out, optional] LPDWORD                 */ lpThreadId: u32*
// ) -> void* /* HANDLE */;
// fn @dllimport CloseHandle(handle: void*) -> bool;
// fn @dllimport WaitForSingleObject(handle: void*, ms: u32) -> u32;
// fn @dllimport GetLastError() -> u32;

// #endif