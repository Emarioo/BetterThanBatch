/*
    This file contains Unix specific features.
    - Wrapper for syscalls
    
    Note that this module is just for convenience.
    The headers for Linux are complex with many #ifdefs (struct_stat.h for example)
    so this file assumes a lot of things. It should be fine on a modern 64-bit Linux machine.

    Most defines are copied from /usr/include/x86_64-linux-gnu/bits/...

    TODO: Sockets, fork, execv, dup, pipe
    TODO: This file is dependent on macros and inline assembly. If those break then this file will not compile. Should we make some sort of backup wrapper?
*/

#if OS_LINUX // wraps everything in this file

#macro STDIN_FILENO  0
#macro STDOUT_FILENO 1
#macro STDERR_FILENO 2


/* open/fcntl.  */
#macro O_RDONLY     00
#macro O_WRONLY      01
#macro O_RDWR       02
#macro O_CREAT    0x80 /* Not fcntl.  */
#macro O_EXCL     0x100 /* Not fcntl.  */
#macro O_NOCTTY    0x200 /* Not fcntl.  */
#macro O_TRUNC   0x800 /* Not fcntl.  */
#macro O_APPEND   0x1000
#macro O_NONBLOCK   0x2000
#macro O_SYNC        0x2008000
#macro O_ASYNC  0x10000
#macro O_LARGEFILE 0x80000
#macro O_DIRECTORY 0x100000
#macro O_NOFOLLOW 0x200000
#macro O_CLOEXEC   0x1000000
#macro O_DIRECT  0x20000
#macro O_NOATIME   0x800000
#macro O_PATH     0x8000000
#macro O_DSYNC  0x8000
#macro O_TMPFILE   (0x10000000 | O_DIRECTORY)

#macro SEEK_SET 0 // seeks from start
#macro SEEK_CUR 1 // seeks from current
#macro SEEK_END 2 // seels from end

#macro PROT_READ 0x1  /* Page can be read.  */
#macro PROT_WRITE 0x2  /* Page can be written.  */
#macro PROT_EXEC 0x4  /* Page can be executed.  */
#macro PROT_NONE 0x0  /* Page can not be accessed.  */

/* Sharing types (must choose one and only one of these).  */
#macro MAP_SHARED 0x01  /* Share changes.  */
#macro MAP_PRIVATE 0x02  /* Changes are private.  */
#macro MAP_SHARED_VALIDATE 0x03 /* Share changes and validate
        extension flags.  */
#macro MAP_TYPE 0x0f  /* Mask for type of mapping.  */

/* Other flags.  */
#macro MAP_FIXED 0x10  /* Interpret addr exactly.  */
#macro MAP_ANONYMOUS 0x20  /* Don't use a file.  */
#macro MAP_32BIT 0x40  /* Only give out 32-bit addresses.  */

#macro MAP_GROWSDOWN 0x00100  /* Stack-like segment.  */
#macro MAP_DENYWRITE 0x00800  /* ETXTBSY.  */
#macro MAP_EXECUTABLE 0x01000  /* Mark it as an executable.  */
#macro MAP_LOCKED 0x02000  /* Lock the mapping.  */
#macro MAP_NORESERVE 0x04000  /* Don't check for reservations.  */
#macro MAP_POPULATE 0x08000  /* Populate (prefault) pagetables.  */
#macro MAP_NONBLOCK 0x10000  /* Do not block on IO.  */
#macro MAP_STACK 0x20000  /* Allocation is for a stack.  */
#macro MAP_HUGETLB 0x40000  /* Create huge page mapping.  */
#macro MAP_SYNC 0x80000  /* Perform synchronous page
        faults for the mapping.  */
#macro MAP_FIXED_NOREPLACE 0x100000 /* MAP_FIXED but do not unmap
        underlying mapping.  */

#macro GRND_NONBLOCK 0x01
#macro GRND_RANDOM 0x02

#macro DT_UNKNOWN 0
#macro DT_FIFO  1
#macro DT_CHR   2
#macro DT_DIR   4
#macro DT_BLK   6
#macro DT_REG   8
#macro DT_LNK   10
#macro DT_SOCK  12
#macro DT_WHT   14

#macro S_IFMT   0o170000 // bit mask for the file type bit field
#macro S_IFSOCK 0o140000 // socket
#macro S_IFLNK  0o120000 // symbolic link
#macro S_IFREG  0o100000 // regular file
#macro S_IFBLK  0o060000 // block device
#macro S_IFDIR  0o040000 // directory
#macro S_IFCHR  0o020000 // character device
#macro S_IFIFO  0o010000 // FIFO

#macro P_ALL  0 /* Wait for any child.  */
#macro P_PID  1 /* Wait for specified process.  */
#macro P_PGID 2 /* Wait for members of process group.  */


/* Bits in the third argument to `waitpid'.  */
#macro	WNOHANG		1	/* Don't block waiting.  */
#macro	WUNTRACED	2	/* Report status of stopped children.  */

/* Bits in the fourth argument to `waitid'.  */
#macro WSTOPPED	2	/* Report stopped child (same as WUNTRACED). */
#macro WEXITED	4	/* Report dead child.  */
#macro WCONTINUED	8	/* Report continued child.  */
#macro WNOWAIT	0x01000000 /* Don't reap, just poll status.  */

/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */
#macro	WEXITSTATUS(status)	(((status) & 0xff00) >> 8)

/* If WIFSIGNALED(STATUS), the terminating signal.  */
#macro	WTERMSIG(status)	((status) & 0x7f)

/* If WIFSTOPPED(STATUS), the signal that stopped the child.  */
#macro	WSTOPSIG(status)	WEXITSTATUS(status)

/* Nonzero if STATUS indicates normal termination.  */
#macro	WIFEXITED(status)	(WTERMSIG(status) == 0)

/* Nonzero if STATUS indicates termination by a signal.  */
#macro WIFSIGNALED(status) ((cast<char> (((status) & 0x7f) + 1) >> 1) > 0)

/* Nonzero if STATUS indicates the child is stopped.  */
#macro	WIFSTOPPED(status)	(((status) & 0xff) == 0x7f)

/* Nonzero if STATUS indicates the child continued after a stop.  We only
   define this if <bits/waitflags.h> provides the WCONTINUED flag bit.  */
#macro WIFCONTINUED(status)	((status) == __W_CONTINUED)

/* Nonzero if STATUS indicates the child dumped core.  */
#macro	WCOREDUMP(status)	((status) & __WCOREFLAG)

/* Macros for constructing status values.  */
// #macro	__W_EXITCODE(ret, sig)	((ret) << 8 | (sig))
// #macro	__W_STOPCODE(sig)	((sig) << 8 | 0x7f)
// #macro __W_CONTINUED		0xffff
// #macro	__WCOREFLAG		0x80

#macro SIGCHLD		17	/* Child terminated or stopped.  */

#macro CLD_EXITED 1               /* Child has exited.  */
#macro  CLD_KILLED 2                   /* Child was killed.  */
#macro  CLD_DUMPED 3                   /* Child terminated abnormally.  */
#macro  CLD_TRAPPED 4                  /* Traced child has trapped.  */
#macro  CLD_STOPPED 5                  /* Child has stopped.  */
#macro  CLD_CONTINUED 6                 /* Stopped child has continued.  */

#macro	R_OK	4		/* Test for read permission.  */
#macro	W_OK	2		/* Test for write permission.  */
#macro	X_OK	1		/* Test for execute permission.  */
#macro	F_OK	0		/* Test for existence.  */

/*#################3
    SYSCALLS
################*/
#macro SYS_read     0
#macro SYS_write    1
#macro SYS_open     2
#macro SYS_close    3
#macro SYS_stat     4
#macro SYS_fstat    5
#macro SYS_lstat    6
// #macro SYS_poll     7
#macro SYS_lseek    8
#macro SYS_mmap     9
#macro SYS_mprotect 10
#macro SYS_munmap   11

#macro SYS_access   21
#macro SYS_pipe   22

#macro SYS_dup   32
#macro SYS_dup2   33

#macro SYS_nanosleep 35

#macro SYS_fork     57
#macro SYS_vfork    58
#macro SYS_execve   59
#macro SYS_exit     60


// #macro SYS_getdents 78
#macro SYS_getcwd     79
#macro SYS_getdents64 217

#macro SYS_waitid 247

#macro SYS_getrandom 318


// General macro for all syscalls
#macro SYSCALL(NAME, RETURN_TYPE, ...)

fn @unixcall @blank NAME( SYSCALL_args(...) ) -> RETURN_TYPE {
    asm {
        push rbp // 16-byte align, I assume syscalls require that
        // sub rsp, 40

        // parameters and return values have already been set
        mov r10, rcx // 4th argument is passed through r10, not rcx
        mov eax, SYS_ ## NAME
        syscall

        pop rbp
        // add rsp, 40
        ret
    }
}
#endmacro
#macro SYSCALL_VOID(NAME, ...)
fn @unixcall @blank NAME( SYSCALL_args(...) ) {
    asm {
        mov eax, SYS_ ## NAME
        syscall
    }
}
#endmacro
#macro SYSCALL_args(X,...) X, SYSCALL_args(...)
#macro SYSCALL_args(X) X
#macro SYSCALL_args() #endmacro
// More than 6 arguments must be passed to the stack
// which the SYSCALL macro doesn't account for.
#macro SYSCALL_args(a,b,c,d,e,f,g) CANT_HAVE_7_ARGS_TO_SYSCALL

// Function calls
// TODO: ALL OF THESE HAVE NOT BEEN TESTED!
SYSCALL(read,  i32,  fd: i32, buf: void*, count: u32)
SYSCALL(write, i32,  fd: i32, buf: void*, count: u32)
SYSCALL(open,  i32,  path: char*, flags: i32, mode: i32 = 0)
SYSCALL(close, i32,  fd: i32)
SYSCALL(stat,  i32,  pathname: char*, statbuf: stat*)
SYSCALL(fstat, i32,  fd: i32, statbuf: stat*);
SYSCALL(lstat, i32,  pathname: char*, statbuf: stat*)
SYSCALL(lseek, i32,  fd: i32, offset: i32, whence: i32)
SYSCALL(mmap,  void*, addr: void*, length: i32, prot: i32, flags: i32, fd: i32, offset: i32)
SYSCALL(mprotect,  i32, addr: void*, len: i32, prot: i32);
SYSCALL(munmap,    i32, addr: void*, length: i32)

SYSCALL(access,  i32, path: char*, mode: i32)
SYSCALL(pipe,  i32, fildes: int*)

SYSCALL(dup, i32, fildes: i32)
SYSCALL(dup2, i32, oldfd: i32, newfd: i32)

SYSCALL(nanosleep, i32, rqtp: timespec*, rmtp: timespec*)

SYSCALL(fork,   i32)
SYSCALL(vfork,  i32)
// environment variables can be be acquired from the envp argument in main(argc: i32, argv: char**, envp: char**)
SYSCALL(execve, i32, pathname: char*, argv: char**, envp: char**)
SYSCALL_VOID(exit,   status: i32)

SYSCALL(getcwd, char*, buf: char*, size: i32)

// SYSCALL(getdents, i32, fd: i32, dirp: linux_dirent*, count: u32);
SYSCALL(getdents64, i32, fd: i32, dirp: void*, count: u32);

SYSCALL(waitid, i32, type: i32, id: i32, info: siginfo*, options: i64, ru: void* = null);

SYSCALL(getrandom, i32, buf: void*, buflen: u32, flags: u32);

// I could not find the correct stat structure anywhere but
// this structure seems to be correct.
struct stat {
    st_dev:         u64;  /* Device.  */
    st_ino:         u64;  /* File serial number. */ 
    st_nlink:       u32;  /* Link count.  */
    _pad23:         u32;
    
    st_mode:        u32;  /* File mode.  */
    st_uid:         u32;  /* User ID of the file's owner. */
    st_gid:         u32;  /* Group ID of the file's group.*/
    
    st_rdev:        u64;  /* Device number, if device.  */

    st_size:        i64;  /* Size of file, in bytes.  */
    st_blksize:     u64;  /* Optimal block size for I/O.  */
    st_blocks:      u64;  /* Number 512-byte blocks allocated. */

    st_atime:       u64;  /* Time of last access.  */
    st_atime_nsec:  u64;  /* Time of last access.  */
    st_mtime:       u64;  /* Time of last modification.  */
    st_mtime_nsec:  u64;  /* Time of last modification.  */
    st_ctime:       u64;  /* Time of last status change.  */
    st_ctime_nsec:  u64;  /* Time of last status change.  */
};

#macro ino64_t u64
#macro off64_t i64
#macro ino_t u32
#macro off_t i32

struct linux_dirent {
    d_ino: ino_t;    /* 64-bit inode number */
    d_off: off_t;    /* Not an offset; see getdents() */
    d_reclen: u16; /* Size of this dirent */

    d_name: char[1]; /* Filename (null-terminated) */

    // access through *(cast<u8*>ptr + d_reclen - 1)
    // d_type: u8;   /* File type */
};

struct linux_dirent64 {
    d_ino: ino64_t;    /* 64-bit inode number */
    d_off: off64_t;    /* Not an offset; see getdents() */
    d_reclen: u16; /* Size of this dirent */
    d_type: u8;   /* File type */

    d_name: char[1]; /* Filename (null-terminated) */
};

// This struct may be incorrect, I could not find a struct that matched
// the values that waitid returned but this order and integer sizes seem to work.
struct siginfo {
    si_signo: i32;
    si_errno: i32;
    si_code : i32;
    uid: i32;
    pid: i32;
    status: i64;
}

struct timespec {
    tv_sec: i64;
    tv_nsec: i64;
}

#macro EPERM    1 /* Operation not permitted */
#macro ENOENT   2 /* No such file or directory */
#macro ESRCH    3 /* No such process */
#macro EINTR    4 /* Interrupted system call */
#macro EIO      5 /* I/O error */
#macro ENXIO    6 /* No such device or address */
#macro E2BIG    7 /* Argument list too long */
#macro ENOEXEC  8 /* Exec format error */
#macro EBADF    9 /* Bad file number */
#macro ECHILD   10 /* No child processes */
#macro EAGAIN   11 /* Try again */
#macro ENOMEM   12 /* Out of memory */
#macro EACCES   13 /* Permission denied */
#macro EFAULT   14 /* Bad address */
#macro ENOTBLK  15 /* Block device required */
#macro EBUSY    16 /* Device or resource busy */
#macro EEXIST   17 /* File exists */
#macro EXDEV    18 /* Cross-device link */
#macro ENODEV   19 /* No such device */
#macro ENOTDIR  20 /* Not a directory */
#macro EISDIR   21 /* Is a directory */
#macro EINVAL   22 /* Invalid argument */
#macro ENFILE   23 /* File table overflow */
#macro EMFILE   24 /* Too many open files */
#macro ENOTTY   25 /* Not a typewriter */
#macro ETXTBSY  26 /* Text file busy */
#macro EFBIG    27 /* File too large */
#macro ENOSPC   28 /* No space left on device */
#macro ESPIPE   29 /* Illegal seek */
#macro EROFS    30 /* Read-only file system */
#macro EMLINK   31 /* Too many links */
#macro EPIPE    32 /* Broken pipe */
#macro EDOM     33 /* Math argument out of domain of func */
#macro ERANGE   34 /* Math result not representable */

fn name_of_error(err: i64) -> char[] {
    err = -err;
    // TODO: Make a global table of strings.
    switch (err) {
        #macro SWITCH_CASES(X,Y,...) case X: return Y; SWITCH_CASES(...)
        SWITCH_CASES(EPERM,"EPERM",
            ENOENT, "ENOENT",
            ESRCH, "ESRCH",
            EINTR, "EINTR",
            EIO, "EIO",
            ENXIO, "ENXIO",
            E2BIG, "E2BIG",
            ENOEXEC, "ENOEXEC",
            EBADF, "EBADF",
            ECHILD, "ECHILD",
            EAGAIN, "EAGAIN",
            ENOMEM, "ENOMEM",
            EACCES, "EACCES",
            EFAULT, "EFAULT",
            ENOTBLK, "ENOTBLK",
            EBUSY, "EBUSY",
            EEXIST, "EEXIST",
            EXDEV, "EXDEV",
            ENODEV, "ENODEV",
            ENOTDIR, "ENOTDIR",
            EISDIR, "EISDIR",
            EINVAL, "EINVAL",
            ENFILE, "ENFILE",
            EMFILE, "EMFILE",
            ENOTTY, "ENOTTY",
            ETXTBSY, "ETXTBSY",
            EFBIG, "EFBIG",
            ENOSPC, "ENOSPC",
            ESPIPE, "ESPIPE",
            EROFS, "EROFS",
            EMLINK, "EMLINK",
            EPIPE, "EPIPE",
            EDOM, "EDOM",
            ERANGE, "ERANGE")
    }
    return "unknown"
}

#endif // OS_LINUX
