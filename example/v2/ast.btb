@version 2
// @disable all
// @enable preprocessor
@disable interpreter
/*
    Data types...
    Enum for primitive ones (i32, bool) 
    As for structs and pointers. There can be many.
    Pointer can have pointers to pointers to pointers.
*/
// i = 1
// while i<5
//     i = i + 1

// fn ekae (a: i32, b: i32) -> i32 { 
//     return 123 + a + b
// }
// a =  ekae(9,7) + 0

// alloc
// realloc
// free

// fn Earth() -> Vec2 {
//     return Vec2{92,912}   
// }

// struct Vec2 {
//     x: u64,
//     y: u64,
// }
// overload +(a: Vec2, b: Vec2) -> Vec2 {
//     return Vec2{a.x+b.x,a.y+b.y}   
// }

// arr: i32[] = [1,5,2,6]

// each arr {
//     nr
//     va
    
// }

// struct ByteArray { ptr: void*, len: u32 }
// fn create(len: u32) -> ByteArray {
//     out = ByteArray{null,0}
//     out.ptr = alloc(len)
//     if out.ptr
//         out.len = len
// }
// fn destroy(arr: ByteArray) { free(arr.ptr,arr.len) }

arr = cast<void*> 0;
// create(5);

// #define PTR(off) *(cast<u8*> (arr.ptr) + off)

// PTR(0) = 50;
// PTR(1) = 50;
// PTR(2) = 50;
// PTR(3) = 50;
// *(cast<u8*> (arr.ptr) + 0) = 50;
*(cast<u8*> (arr) + 0) = 50;
*(cast<u8*> (arr) + 1) = 50;
// *(cast<u8*> (arr.ptr) + 2) = 50;
// *(cast<u8*> (arr.ptr) + 3) = 50;

// k = *(cast<u8*>(arr.ptr)+2)

// destroy(arr)

// m = *arr.ptr

// k = hey

// fn vaargs(...) {
    
//     vaarg.type   
// }

// #define macro(X,...) #isint #isstr #isfloat

// num = 0
// str = ""
// printf("Hello % %\n",str,num)



// prints
// printi
// printd

// i = 0
// while i < 10 {
    
    
//     i++   
// }

// for i {
//     nr
//     va   
// }

// for x..arr

// for x..10 {
    
    
// }

// b = Earth()
// // k = b.x
// i = b.y

// k = Vec2{99,33};

// d = k.y


// b = 92913 - 912

// a = alloc(b)


// free(a,b)
// a = alloc()

// a = 


// a = cast<f32> 9923
// a = alloc(cast<u64>8)

// *a = 8

// (*(p+8))[23] = 9
// p[1] = 9
// *p[23] = 9

// *a = 5
// b = * cast<u64*>a
// b = a
// free(a,cast<u64>8)

// a : u8 = 2.5
// b : u16 =  

// push, u8

// fn poly<T>(ptr: T*) -> i32 { return ptr<T*>( }


// a : i32 = (i32) 2.4

// a = <i32> 2.4
// a = <i32> 2.45 as i32

// a = 9 <i32> <Array>koekoa +

// 2.45 <i32>

// 232 + cast<i32> koekao

//  poly<Zombie>(&zombie)
 
//  poly   <   Zombie**  >   (&zombie)


// poly < cake  && cake > poi
// bool > poi


// print "hello"

// cast<i32> 0.293

// cast<F,T> : (F t) -> T {
//     ...
// }
// cast<>
// fn function(a : i32,b : u32) -> bool {

// }

// p : i32* = &a
// p : i32[] = {&a,1,length: 92}
// p : i32[] = [1,9,2,5,7]