// @import ./module as Mod
// @import ./module
// #import "./Array" as Ok

namespace A {
    struct HE{
        a: i32*,
    }
}

t: A::HE;
t.a = 2;

// a: Ok::Array;
// a.ptr = null;
// a.size = 5;

// namespace A {
//     struct B { a: i32, }   
// }

// a: B;
// namespace A {
//     namespace CC {
//         enum B {
//             One = 99, 
//         }
//     }
// }
// namespace OKK{
//     namespace N2 {
//         struct OK{
//             a: A::CC::B,
//         }
//     }
// }
// namespace A {
//     namespace CC {
//         struct SE {
//             sup: OKK::N2::OK,
//         }
//     }
// }
// a = A{Hey.Two};
// namespace NO {
//     struct A {
//         a: N::Hey,
//     }
// }

// a = "A"
// printc(a)
// // b = 9
// printi(a)

// i = 0
// while i < 10 {
//     printi(i)
//     i+=1
// }

// a: A;

// a: N::Hey;
// a = N::Hey.Two;



// a = NO::A{N::Hey.Two};
// namespace N {
//     struct CC {
//         bb: NO::A,
//     }
//     enum Hey {
//         Zero,
//         One,
//         Two,   
//     }
// }

// a: N2::A
// namespace N2 {
//     struct A {
//         a: N1::A
//     }   
// }
// namespace N1 {
//     enum A {
        
//     }   
// }
// a = A::B.One;
// printi(a)
// namespace Math {
//     enum Const { PI=3, E=2 }
// }
// globl = Math::Const.PI
// printi(globl)

// namespace Math {
//     fn cool(){}
// }

// glob: Type;
// {
//     enum Type {Yes}
// }
// glob = Type.Yes

// glob = Math::Const.one

// printi(9<<2)

// {
// 	enum Size {
// 		Tiny,
// 		Massive
// 	}
// 	local = Size.Massive
//     printi(local)
// }
// global = local             //<- local is undefined
// globalEnum = Size.Massive  //<- Size is undefined

// a = 9

// global = HM{};

// printi(a.n)

// printi(1)

// printi(5)

// #include "example/module.btb"
// #include "./module.btb"

// struct Array {
//     ptr: void*,
//     size: u64,   
// }
// arr: Array;

// arr: Array;

// arr.ptr = alloc(8);
// arr.size = 8;

// the list of typeInfos is global
// not good? add scope levels?

// {
//     struct A {
//         num: i32 = 23
//     }
// }
// {
//     a: A = A{0}
// }
// a = 9
// fn sort(ptr: i32* = 0, len: i32, reverse: u8) {
//     printi(ptr)
//     printi(len)
//     printi(reverse)
// }

// fn test(a: i32 = 9, b: i32 = 1){
//     printi(a)
//     printi(b)
// }

// test(5,6)
// test(b= 5, a = 43)
// test(b = 2)
// test(6)

// sort(32,1)

// a: A;
// printi(a.num)

// fn max(a, b) -> i32;

// fn fun() {
//     namespace Mini {
//         struct Okay{
//             a: i32,
//             b: i32,   
//         }
//         callFunc()   
        
//         N = 9
//         E = 2.718
//         base = Okay{max(PI,5),2}
//     }
    
//     ok: Mini::Okay;
//     ok.a = Mini::PI
//     ok.b = Mini::E
// }


// #define TYPE u64
// #define TYPE i32
// struct B {
//     n : TYPE
// }
// struct A {
//     ol: TYPE,
//     b: B
// }
// a: A = A{3,B{5}};
// // b = 9
// a.b.n = 9
// a.ol = 3

// ;*(&a + 2) = 5
// ;*(&a + 4) = 5
// printi(a.ol)
// printi(a.b.n)
// printi(a.b.n)

// k = a.ol

// struct A {
//     a: i32,
//     // b: i64,
//     c: i32,
// }
// fn print(a: A) {
//     printi(a.a)
//     // printi(a.b)
//     printi(a.c)
// }

// print(A{1,cast<i64>2,3})

// fn te(a: i32, b: i8) -> i32 {
// // fn te(a: i32, b: u8, c: u16, d: i32) -> i32 {
//     return 29 + a + cast<i32>b
// }

// a = te(22,-33)
// // a: i8 = 29
// printi(a)

// c: i8 = 22
// a = A{55,66}

// k = a.c
// k = c
// k = b

// a: A = A{1,cast<i64>2,3};
// i32 = 5;
// i64 = 10;

// struct C {
//     a: i32,
// }

// struct B {
//     int: i32,
//     c: C,
// }
// struct A {
//     slice: i32[],
//     b: B,
//     a: bool,
// }



// struct Linked<T> {
//     start: Item,
//     struct Item {
//         value: T,
//         exist: Exist,
//         next: Item*,
//     }
//     enum Available {
//         Yes,
//         No,
//     }
// }

// struct Array<T> {
//     a: Item,
//     struct Item {
//         index: T,
//         value: bool,
//     }
// }

// Array<Array<i32>>