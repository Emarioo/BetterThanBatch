// @disable all
// @enable preprocessor
// @disable interpreter

// @import ./module.btb

#include "example/module.btb"
#include "./module.btb"

// struct Array {
//     ptr: void*,
//     size: u64,   
// }
arr: Array;

// arr: Array;

// arr.ptr = alloc(8);
// arr.size = 8;

// the list of typeInfos is global
// not good? add scope levels?

// {
    // struct A {
    //     num: i32 = 23
    // }
// }
// {
//     a: A = A{0}
// }
// a = 9
// fn sort(ptr: i32* = 0, len: i32, reverse: u8) {
//     printi(ptr)
//     printi(len)
//     printi(reverse)
// }

// fn test(a: i32 = 9, b: i32 = 1){
//     printi(a)
//     printi(b)
// }

// test(5,6)
// test(b= 5, a = 43)
// test(b = 2)
// test(6)

// sort(32,1)

// a: A;
// printi(a.num)

// fn max(a, b) -> i32;

// fn fun() {
//     namespace Mini {
//         struct Okay{
//             a: i32,
//             b: i32,   
//         }
//         callFunc()   
        
//         N = 9
//         E = 2.718
//         base = Okay{max(PI,5),2}
//     }
    
//     ok: Mini::Okay;
//     ok.a = Mini::PI
//     ok.b = Mini::E
// }


// #define TYPE u64
// #define TYPE i32
// struct B {
//     n : TYPE
// }
// struct A {
//     ol: TYPE,
//     b: B
// }
// a: A = A{3,B{5}};
// // b = 9
// a.b.n = 9
// a.ol = 3

// ;*(&a + 2) = 5
// ;*(&a + 4) = 5
// printi(a.ol)
// printi(a.b.n)
// printi(a.b.n)

// k = a.ol

// struct A {
//     a: i32,
//     // b: i64,
//     c: i32,
// }
// fn print(a: A) {
//     printi(a.a)
//     // printi(a.b)
//     printi(a.c)
// }

// print(A{1,cast<i64>2,3})

// fn te(a: i32, b: i8) -> i32 {
// // fn te(a: i32, b: u8, c: u16, d: i32) -> i32 {
//     return 29 + a + cast<i32>b
// }

// a = te(22,-33)
// // a: i8 = 29
// printi(a)

// c: i8 = 22
// a = A{55,66}

// k = a.c
// k = c
// k = b

// a: A = A{1,cast<i64>2,3};
// i32 = 5;
// i64 = 10;

// struct C {
//     a: i32,
// }

// struct B {
//     int: i32,
//     c: C,
// }
// struct A {
//     slice: i32[],
//     b: B,
//     a: bool,
// }



// struct Linked<T> {
//     start: Item,
//     struct Item {
//         value: T,
//         exist: Exist,
//         next: Item*,
//     }
//     enum Available {
//         Yes,
//         No,
//     }
// }

// struct Array<T> {
//     a: Item,
//     struct Item {
//         index: T,
//         value: bool,
//     }
// }

// Array<Array<i32>>