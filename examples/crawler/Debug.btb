
#import "Math"
#import "Logger"
#import "Array"

#import "./GameCore" // Entity

// #macro MAX_FRAMES (60 * 60*2) // 2 minutes
#macro MAX_FRAMES (60 * 5) // 5 sec
struct Frame {
    changes: Array<Entity>
}
global last_frame: i32
global saved_frames: i32
global frames: Array<Frame>
global permanent_frames: Array<Frame>
global permanent_frames_indices: Array<i32>
fn SavePermanentFrame(frame_index: i32) {
    // NOTE: This broke, entities is now bucket array
    // if frame_index < 0
    //     frame_index = 0

    // permanent_frames.add(Frame{})
    // permanent_frames_indices.add(frame_index)
    // frame := permanent_frames.last()

    // // TODO: only store changes
    // frame.changes.resize(entities.size())
    // memcpy(frame.changes.ptr, entities.ptr, entities.size() * sizeof Entity)
}
fn SaveFrame(frame_index: i32) {
    // NOTE: This broke, entities is now bucket array
    // if frame_index < 0
    //     frame_index = 0

    // if frame_index > last_frame {
    //     last_frame = frame_index
    //     if saved_frames < MAX_FRAMES
    //         saved_frames++
    // }

    // real_index := frame_index % MAX_FRAMES

    // frame: Frame*;
    // if frames.size() <= real_index {
    //     frames.add(Frame{})
    //     frame = frames.last()
    //     // TODO: Erase future frames?
    // } else {
    //     frame = frames.get_unsafe(real_index)
    // }

    // // TODO: only store changes
    // frame.changes.resize(entities.size())
    // memcpy(frame.changes.ptr, entities.ptr, entities.size() * sizeof Entity)
}
fn EraseFutureFrames(frame_index: i32) {
    if frame_index < 0
        frame_index = 0
    diff := last_frame - frame_index
    if diff > MAX_FRAMES
        saved_frames = 0
    else
        saved_frames = diff
    last_frame = frame_index
}
fn GetSavedFrames() -> i32 {
    return saved_frames
}
fn HasPreviousFrame(frame_index: i32) -> bool {
    // TODO: Check off-by-one error
    if frame_index-1 <= last_frame - MAX_FRAMES {
        return false
    }
    return true
}
fn IsLastFrame(frame_index: i32) -> bool {
    if frame_index < 0
        frame_index = 0
    return last_frame <= frame_index
}
fn FrameMemoryUsage() -> i32 {
    // we do a quick estimation
    ents := 0
    if frames.size()
        ents = frames.last().changes.max
    sum := frames.max * (sizeof (Frame) + ents * sizeof Entity)
    return sum
}
fn RestoreFrame(frame_index: i32) {
    // NOTE: This broke when entities became a bucket array, we can't just resize it
    // if frame_index < 0
    //     frame_index = 0

    // for permanent_frames_indices.sliced() {
    //     if it == frame_index {
    //         frame := permanent_frames.get_unsafe(nr)
    //         entities.resize(frame.changes.size())
    //         memcpy(entities.ptr, frame.changes.ptr, frame.changes.size() * sizeof Entity)
    //         return;
    //     }
    // }

    // real_index := frame_index % MAX_FRAMES

    // frame := frames.get_unsafe(real_index)
    // entities.resize(frame.changes.size())
    // memcpy(entities.ptr, frame.changes.ptr, frame.changes.size() * sizeof Entity)
}
