#import "String"
#import "Logger"
#import "Array"

struct ChatWidget {
    x: f32;
    y: f32;
    w: f32;
    h: f32;

    text_size: f32;

    user_name: StringBuilder;

    messages: Array<StringBuilder>;
    input_message: StringBuilder;
    cursor_pos: i32;

    fn add_msg(str: StringBuilder) {
        messages.add(str)
    }

    fn init(_x: f32, _y: f32, _w: f32, _h: f32) {
        x = _x;
        y = _y;
        w = _w;
        h = _h;
        text_size = 20.0
    }
    // TODO: set_width/height methods

    fn render(window: WindowContext*) {
        EditText(window, &input_message, &cursor_pos)

        if window.isKeyPressed(GLFW_KEY_ENTER) {
            if find("/", input_message.sliced()) == 0 {
                // command
                args := split(" ",input_message.sliced())
                // log(&args)
                if args.len == 0 {
                    // what?
                } else if args[0] == "/help" {
                    tmp: StringBuilder
                    tmp.append("Help:\n")
                    tmp.append(" /start [port] - Start server\n")
                    tmp.append(" /connect [ip] [port] - Start client\n")
                    tmp.append(" /stop - Stop server or client")
                    add_msg(tmp)
                } else if args[0] == "/stop" {
                    if server.is_active()
                        server.close()
                    if client.is_active()
                        client.close()
                } else if args[0] == "/setname" {
                    user_name.clear()
                    user_name.append(args[1])
                } else if args[0] == "/start" {
                    // TODO: start and connect commands always use defaul port and never the optional
                    //   one provided by the user.
                    // TODO: If client or server, close them.
                    //   This may take some time so we should probably do it in another thread.
                    is_server = true
                    if server.is_active()
                        server.close()
                    if client.is_active()
                        client.close()
                    server.start(DEFAULT_PORT, NET_TCP | NET_PROTO_MESSAGE)
                } else if args[0] == "/connect" {
                    // if args.len < 2 {
                    //     log("ERROR: /connect expects at least one argument, ip and optionally port. You provided ", args.len-1," argument(s).")
                    // } else {
                        is_server = false
                        if server.is_active()
                            server.close()
                        if client.is_active()
                            client.close()
                        if args.len > 1 {
                            client.start(args[1], DEFAULT_PORT, NET_TCP | NET_PROTO_MESSAGE)
                        } else {
                            client.start("127.0.0.1", DEFAULT_PORT, NET_TCP | NET_PROTO_MESSAGE)
                        }
                    // }
                }
                input_message.clear()
            } else {

                // log("Pressed enter")
                sender: StringBuilder
                defer sender.cleanup()
                if user_name.size() != 0 {
                    sender.append(user_name)
                } else if is_server {
                    sender.append("Server")
                } else {
                    sender.append("Client")
                }

                header: NetMessage
                header.header.type = MSGTYPE_MESSAGE
                header.sender_len = sender.size()
                header.text_len = input_message.size()

                stream: ByteStream
                defer stream.cleanup()
                stream.reserve(sizeof (NetMessage) + sender.size() + input_message.size() + 20)

                stream.write(&header, sizeof header)
                stream.write(sender.data(), header.sender_len)
                stream.write(input_message.data(), header.text_len)

                // FileWrite("bin.txt", stream.sliced_unsafe())

                if is_server {
                    server.send(stream.sliced_unsafe())
                } else {
                    client.send(stream.sliced_unsafe())
                }
                tmp: StringBuilder
                tmp.append("You: ")
                tmp.append(input_message)
                add_msg(tmp)
                input_message.clear()
            }
        }

        layout_y := y
        padding := 5
        draw_info: DrawTextInfo
        // TODO: Rendering 10000 messages will be slow.
        //   If we don't have scroll, we can throw away unnecessary messages.
        //   With scroll we can render the messages that fit on the screen, messages outside can be skipped.
        //   For that we need to know the height of each message, more specifically, the amount of newlines in the message.
        //   This should be stored alongside the text context for each message so we don't recompute it every time.
        for @ptr messages.sliced() {
            DrawText(window, x + padding, padding + layout_y, text_size, it.sliced(), out_info = &draw_info)
            // layout_y += text_size
            layout_y += draw_info.drawn_height
        }
        // TODO: Support newlines in input message? shift+enter? We also need to offset the render position
        //   so the whole input message fits on the screen.
        DrawText(window, padding + x, padding + y + h - text_size - 2*padding, text_size, input_message.sliced(), cursor = cursor_pos)
    }
}