/*
    A crude version control tool
*/

#import "String"
#import "Array"
#import "Logger"
#import "OS"
#import "Stream"
#import "Math"
#import "Basic"

/*
No files

branch add A
branch A
Add a.txt
snap add

branch add B
branch B
Add b.txt
snap add

switch between branches and see respective text file

*/


fn main(argc: i32, argv: char**) {
    workspace: Workspace
    path: StringBuilder
    path.append("examples/version_control/workspace_a")
    workspace.init(&path)

    if argc < 2 {
        log("Crude version control v0.0.1")
        log(" Branches: ", workspace.branches.size())
        log(" Snapshots: ", workspace.snapshots.size())
        log("Help message")
        return
    } else {
        if equal(argv[1], "branch") {
            if(argc < 3) {
                if workspace.branches.size() == 0 {
                    log("No branches")   
                }
                for @ptr workspace.branches.sliced_unsafe() {
                    if workspace.active_branch == it.id {
                        log(" *",it.name.sliced())
                    } else {
                        log("  ",it.name.sliced())
                    }
                }
            } else if equal(argv[2], "del") {
                if argc < 4 {
                    log("Missing branch name")
                    log("Usage: branch del [name] - delete branch")
                } else {
                    name: Slice<char> = Slice<char>{argv[3], strlen(argv[3])}
                    found := workspace.find_index_of_branch(name)
                    if found == -1 {
                        log("'",name,"' is not a branch")
                        log("Suggestion: branch - see available branches")
                    } else {
                        if workspace.active_branch == workspace.branches.get_unsafe(found).id {
                            log("Cannot delete the active branch '",name,"'")
                            log("Switch to another branch first")
                        } else {
                            log("Deleted branch '",name,"'")
                            workspace.branches.remove(found)
                        }
                    }
                }
            } else if equal(argv[2], "add") {
                if argc < 4 {
                    log("Missing branch name")
                    log("Usage: branch add [name] - delete branch")
                } else {
                    name: Slice<char> = Slice<char>{argv[3], strlen(argv[3])}
                    found := workspace.find_index_of_branch(name)
                    if found == -1 {
                        workspace.create_branch(name)
                        log("Created branch '",name,"'")
                    } else {
                        log("Cannot create branch '",name,"' because it already exists")
                    }
                }
            } else if equal(argv[2], "help") {
                log("Usage: branch [name] - switch to branch")
                log("       branch add [name] - create branch")
                log("       branch del [name] - delete branch")
            } else {
                name: Slice<char> = Slice<char>{argv[2], strlen(argv[2])}
                found := workspace.find_index_of_branch(name)
                if found == -1 {
                    log("'",name,"' is not a branch")
                    log("Suggestion: branch - see available branches")
                } else {
                    b := workspace.branches.get_unsafe(found)
                    if workspace.active_branch == b.id {
                        log("Branch '",name,"' is already active")
                    } else {
                        workspace.switch_branch(b.id)
                        log("Switched to branch '",name,"'")
                    }
                }
            }
        } else if equal(argv[1], "snap") {
            if(argc < 3) {
                if workspace.active_branch == 0 {
                    log("No active branch")
                    return
                }
                branch := workspace.find_branch(workspace.active_branch)
                if !branch {
                    log("Branch was null!")   
                    return
                }
                
                snapshot := workspace.find_snapshot(branch.snapshot)
                if !snapshot {
                    log("No snapshots for branch '",branch.name.sliced(),"'")
                    return
                }
                while snapshot {
                    log(" #",snapshot.id.n,": ", snapshot.description.sliced())
                    
                    snapshot = workspace.find_snapshot(snapshot.parent)
                }
            } else if equal(argv[2], "del") {
                log("del is incomplete")
                // if argc < 4 {
                //     log("Missing branch name")
                //     log("Usage: branch del [name] - delete branch")
                // } else {
                //     name: Slice<char> = Slice<char>{argv[3], strlen(argv[3])}
                //     found := workspace.find_index_of_branch(name)
                //     if found == -1 {
                //         log("'",name,"' is not a branch")
                //         log("Suggestion: branch - see available branches")
                //     } else {
                //         if workspace.active_branch == workspace.branches.get_unsafe(found).id {
                //             log("Cannot delete the active branch '",name,"'")
                //             log("Switch to another branch first")
                //         } else {
                //             log("Deleted branch '",name,"'")
                //             workspace.branches.remove(found)
                //         }
                //     }
                // }
            } else if equal(argv[2], "add") {
                id: SnapshotID
                if argc > 3 {
                    desc := Slice<char>{argv[3], strlen(argv[3])}
                    id = workspace.create_snapshot(desc)
                } else {
                    id = workspace.create_snapshot()
                }
                
                if id.n != 0
                    log("Created snapshot")
            } else if equal(argv[2], "desc") {
                if argc < 4 {
                    log("Missing snapshot description")
                    log("Usage: snap desc [text]")
                } else {
                    if workspace.active_branch == 0 {
                        log("No active branch")
                        return
                    }
                    branch := workspace.find_branch(workspace.active_branch)
                    if !branch {
                        log("Branch was null!")   
                        return
                    }
                    
                    text := Slice<char>{argv[3], strlen(argv[3])}
                    yes := workspace.rename_snapshot(branch.snapshot, text)
                    
                    if yes {
                        log("Description of #",branch.snapshot.n, " was replaced")
                    }
                }
            } else if equal(argv[2], "help") {
                log("Usage: snap - list snapshots of current branch")
                log("       snap add - create snapshot")
                log("       snap desc [text] - set/replace description of last snapshot")
                log("       snap desc #[id] [text] - set/replace description of specified snapshot")
                log("       snap del #[id] - delete snapshot")
            } else {
                log("bad command, see snap help")
                // name: Slice<char> = Slice<char>{argv[2], strlen(argv[2])}
                // found := workspace.find_index_of_branch(name)
                // if found == -1 {
                //     log("'",name,"' is not a branch")
                //     log("Suggestion: branch - see available branches")
                // } else {
                //     b := workspace.branches.get_unsafe(found)
                //     if workspace.active_branch == b.id {
                //         log("Branch '",name,"' is already active")
                //     } else {
                //         workspace.switch_branch(b.id)
                //         log("Switched to branch '",name,"'")
                //     }
                // }
            }
        } else if equal(argv[1], "log") {
            if workspace.history.size() == 0 {
                log("Log is empty")
                return
            }
            
            for @ptr workspace.history.sliced_unsafe() {
                log(" ", it.content.sliced())
            }
        } else if equal(argv[1], "status") {
            if workspace.files.size() == 0 {
                log("No tracked files")
                return
            }
            
            for @ptr workspace.files.sliced_unsafe() {
                log(" ", it.path.sliced())
            }
        }else {
            log("Unknown argument: ",argv[1])
            return
        }
    }
    // cvc branch
    // cvc del branch main
    // cvc rename branch main dev
    // cvc commit
    
    // for 0..argc {
    //     log(argv[nr])
    // }
    
    
    // workspace.create_branch("v0.1");
    // workspace.create_snapshot("First version");
    
    workspace.save_all()
}

struct WorkspaceFile {
    path: StringBuilder;
    lastModified: u64;
    
    marked: bool; // used when comparing files to know which ones are missing
}
struct Workspace {
    root_dir: StringBuilder;
    workspace_dir: StringBuilder;
    snapshots_dir: StringBuilder;
    config_dir: StringBuilder;
    history_dir: StringBuilder;
    
    snapshots: DynamicArray<Snapshot>;
    branches: DynamicArray<Branch>;
    history: DynamicArray<LogOperation>;
    
    active_branch: BranchID;
    active_snapshot: SnapshotID;
    
    files: DynamicArray<WorkspaceFile>;
    #macro WORKSPACE_SUB_DIR ".cvc"
    
    // initialize the workspace
    // if the directory has a workspace directory then we
    // setup things up based on it.
    // otherwise we create a new workspace.
    fn init(path: StringBuilder*) -> bool {
        is_dir: bool;
        found_path := FileExist(path.sliced(), is_dir = &is_dir)
        if !found_path || !is_dir {
            log("Cannot initialized workspace at '", path.sliced(), "'. It is not a valid path to a directory.")
            return false
        }
        
        root_dir = *path
        
        
        workspace_dir.clear()
        workspace_dir.append(root_dir.sliced());
        workspace_dir.append("/");
        workspace_dir.append(WORKSPACE_SUB_DIR);
        
        found := FileExist(workspace_dir.sliced(), is_dir = &is_dir)
        if found && !is_dir {
            log("Cannot initialized workspace at '", path.sliced(), "'. A file named '", WORKSPACE_SUB_DIR, "' is not allowed. It is reserved for workspace content. Consider removing the file if you want a workspace in the directory.")
            return false
        }
        
        if found {
            // log("Loading existing workspace")
            // load existing workspace
        } else {
            // log("Creating new workspace")
            // create new workspace
            
            yes := DirCreate(workspace_dir.sliced())
            if !yes {
                log("Failed creating directory '",workspace_dir.sliced(),"'")
                return false
            }
        }
        
        snapshots_dir.append(workspace_dir)
        snapshots_dir.append("/snapshots")
        config_dir.append(workspace_dir)
        config_dir.append("/config")
        history_dir.append(workspace_dir)
        history_dir.append("/history")
        
        load_config()
        load_snapshots()
        load_history()
        
        
        
        return true
    }
    fn save_all() {
        save_config()
        save_snapshots()
        save_history()
    }
    
    // SAVING AND LOADING VERSION CONTROL INFORMATION
    
    fn load_config() -> bool {
        file_size: u64;
        file := FileOpen(config_dir.sliced(), FILE_READ_ONLY, &file_size)
        if !file   return false
        // defer FileClose(file)
        
        stream: ByteStream
        yes := stream.reserve(file_size)
        
        if !yes
            return false
        FileRead(file, stream.data, file_size)
        FileClose(file) // close file as soon as we are done instead of defering to the end of the function
        
        stream.read(&active_branch, sizeof active_branch)
        stream.read(&active_snapshot, sizeof active_snapshot)
        
        branch_count: u32;
        stream.read<u32>(&branch_count)
        
        branches.resize(branch_count)
        
        for @ptr branches.sliced_unsafe() {
            stream.read(&it.id, sizeof it.id)
            desc_len: u16;
            stream.read<u16>(&desc_len)
            if desc_len != 0 {
                it.name._reserve(desc_len)
                it.name.len = desc_len
                stream.read(it.name.ptr, it.name.len)
            }
            stream.read(&it.snapshot, sizeof it.snapshot)
        }
        
        file_count: u32;
        stream.read<u32>(&file_count)
        files.resize(file_count)
        
        for @ptr files.sliced_unsafe() {
            len: u16
            stream.read<u16>(&len)
            if len != 0 {
                it.path._reserve(len)
                it.path.len = len
                stream.read(it.path.ptr, it.path.len)
            }
            stream.read<u64>(&it.lastModified)
        }
        
        return true
    }
    fn save_config() -> bool {
        stream: ByteStream
        
        stream.write(&active_branch, sizeof active_branch)
        stream.write(&active_snapshot, sizeof active_snapshot)
        
        stream.write<u32>(branches.size())
        
        for @ptr branches.sliced_unsafe() {
            stream.write(&it.id, sizeof it.id)
            stream.write<u16>(it.name.size())
            if it.name.size() != 0 {
                slice := it.name.sliced()
                stream.write(slice.ptr, slice.len)
            }
            stream.write(&it.snapshot, sizeof it.snapshot)
        }
        
        stream.write<u32>(files.size())
        
        for @ptr files.sliced_unsafe() {
            stream.write<u16>(it.path.size())
            if it.path.size() != 0 {
                slice := it.path.sliced()
                stream.write(slice.ptr, slice.len)
            }
            stream.write<u64>(it.lastModified)
        }
        
        file := FileOpen(config_dir.sliced(), FILE_CLEAR_AND_WRITE)
        if !file   return false
        defer FileClose(file)
        
        slice := stream.sliced_unsafe()
        FileWrite(file, slice.ptr, slice.len)
        
        return true
    }
    fn load_snapshots() -> bool {
        file_size: u64;
        file := FileOpen(snapshots_dir.sliced(), FILE_READ_ONLY, &file_size)
        if !file   return false
        // defer FileClose(file)
        
        stream: ByteStream
        yes := stream.reserve(file_size)
        
        if !yes
            return false
        FileRead(file, stream.data, file_size)
        FileClose(file) // close file as soon as we are done instead of defering to the end of the function
        
        snapshot_count: u32;
        stream.read<u32>(&snapshot_count)
        
        snapshots.resize(snapshot_count)
        
        for @ptr snapshots.sliced_unsafe() {
            stream.read(&it.id, sizeof it.id)
            desc_len: u16;
            stream.read<u16>(&desc_len)
            if desc_len != 0 {
                it.description._reserve(desc_len)
                it.description.len = desc_len
                stream.read(it.description.ptr, it.description.len)
            }
            stream.read(&it.parent, sizeof it.parent)
        }
        
        return true
    }
    fn save_snapshots() -> bool {
        stream: ByteStream
        
        stream.write<u32>(snapshots.size())
        
        for @ptr snapshots.sliced_unsafe() {
            stream.write(&it.id, sizeof it.id)
            stream.write<u16>(it.description.size())
            if it.description.size() != 0 {
                slice := it.description.sliced()
                stream.write(slice.ptr, slice.len)
            }
            stream.write(&it.parent, sizeof it.parent)
        }
        
        
        file := FileOpen(snapshots_dir.sliced(), FILE_CLEAR_AND_WRITE)
        if !file   return false
        defer FileClose(file)
        
        slice := stream.sliced_unsafe()
        FileWrite(file, slice.ptr, slice.len)
        
        return true
    }
    fn load_history() -> bool {
        file_size: u64;
        file := FileOpen(history_dir.sliced(), FILE_READ_ONLY, &file_size)
        if !file   return false
        // defer FileClose(file)
        
        stream: ByteStream
        yes := stream.reserve(file_size)
        
        if !yes
            return false
        FileRead(file, stream.data, file_size)
        FileClose(file) // close file as soon as we are done instead of defering to the end of the function
        
        history_count: u32;
        stream.read<u32>(&history_count)
        history.resize(history_count)
        
        stream.read<char>(null) // skip newline
        
        for @ptr history.sliced_unsafe() {
            content_len: u16;
            stream.read<u16>(&content_len)
            if content_len != 0 {
                it.content._reserve(content_len)
                it.content.len = content_len
                stream.read(it.content.ptr, it.content.len)
            }
            stream.read<char>(null) // skip newline
        }
        
        return true
    }
    fn save_history() -> bool {
        stream: ByteStream
        
        stream.write<u32>(history.size())
        stream.write<char>('\n')
        
        for @ptr history.sliced_unsafe() {
            stream.write<u16>(it.content.size())
            if it.content.size() != 0 {
                slice := it.content.sliced()
                stream.write(slice.ptr, slice.len)
            }
            stream.write<char>('\n')
        }
        
        file := FileOpen(history_dir.sliced(), FILE_CLEAR_AND_WRITE)
        if !file   return false
        defer FileClose(file)
        
        slice := stream.sliced_unsafe()
        FileWrite(file, slice.ptr, slice.len)
        
        return true
    }
    
    // OPERATIONS ON THE WORKSPACE
    
    fn create_branch(name: char[]) -> BranchID {
        branches.add(Branch{})
        b := branches.get_unsafe(branches.size()-1)
        
        b.id.n = random64()
        b.name.append(name)
        // b.snapshot = 
        
        tmp: StringBuilder
        tmp.append("branch add ")
        tmp.append(name)
        tmp.append(" (#")
        tmp.append(b.id.n)
        tmp.append(")")
        add_history(tmp.sliced())
        return b.id
    }
    fn remove_branch(id: BranchID) -> bool {
        if active_branch == id {
            return false
        }
        
        found := find_index_of_branch(id)
        if found == -1
            return false
            
        b := branches.get_unsafe(found)
        
        tmp: StringBuilder
        tmp.append("branch del ")
        tmp.append(b.name)
        tmp.append(" (#")
        tmp.append(b.id.n)
        tmp.append(")")
        add_history(tmp.sliced())
        
        branches.remove(found)
    }
    fn switch_branch(id: BranchID) -> bool {
        tmp: StringBuilder
        
        found := find_index_of_branch(id)
        
        if found == -1 {
            tmp.append("branch #")
            tmp.append(id.n)
            tmp.append(" (missing branch name)")
        } else {
            b := branches.get_unsafe(found)
            tmp.append("branch ")
            tmp.append(b.name)
            tmp.append(" (#")
            tmp.append(id.n)
            tmp.append(")")
        }
        add_history(tmp.sliced())
        
        // we need to switch snapshots, delete, create files
        
        
        active_branch = id
        
        return true
    }
    fn switch_snapshot(id: SnapshotID) -> bool {
        // replace files
    }
    
    fn create_snapshot(desc: char[] = "") -> SnapshotID {
        branch := find_branch(active_branch)
        if !branch {
            log("No active branch!")   
            return SnapshotID{}
        }
        prev_snaphot := find_snapshot(branch.snapshot)        
        
        // ##### Check file changes ############
        
        has_change := false
        
        tmp_slice := root_dir.sliced()
        iterator := DirectoryIteratorCreate(&tmp_slice)
        
        // If we ensure that files aren't marked then we don't need this loop
        // This is not the case right now though
        for @ptr files.sliced_unsafe() {
            it.marked = false
        }
        
        while iterator.next() {
            if iterator.result.isDirectory {
                if matchEnd(iterator.result.name, "/.cvc") {
                    iterator.skip()
                }
                continue
            }
            
            relative_path := Slice<char>{iterator.result.name.ptr + tmp_slice.len + 1, iterator.result.name.len - tmp_slice.len - 1}
            
            found := -1
            for @ptr files.sliced_unsafe() {
                if equal(it.path.sliced(), relative_path) {
                    it.marked = true
                    found = nr
                    break
                }
            }
            if found == -1 {
                // creation
                log("New ", relative_path)
                has_change = true
                track_file(relative_path, iterator.result.lastModified)
            } else {
                // modified
                f := files.get_unsafe(found)
                if iterator.result.lastModified > f.lastModified {
                    log("Modified ", relative_path)
                    has_change = true
                    track_file(relative_path, iterator.result.lastModified, found)
                }
            }
            // log(relative_path)
            // log(iterator.result.name)
        }        
        DirectoryIteratorDestroy(iterator)
        
        for files.sliced_unsafe() { // can't do "for files.sliced()" because we modify files inside the loop
            if !it.marked {
                // deletion
                log("Deleted ", it.path)
                has_change = true
                files.remove(nr) // is this safe?
                nr--
            } else {
                it.marked = false
            }
        }
        
        if !has_change {
            log("No file changes, snapshot will not be created")
            return SnapshotID{}
        }
        
        // #### Create snapshot ####
        
        snapshots.add(Snapshot{})
        s := snapshots.get_unsafe(snapshots.size()-1)
        
        s.id.n = random64()
        s.description.append(desc)
        
        if prev_snaphot {
            s.parent = prev_snaphot.id
            branch.snapshot = s.id
        } else {
            branch.snapshot = s.id
        }
        active_snapshot = s.id
        
        tmp: StringBuilder
        tmp.append("snap add ")
        tmp.append(desc)
        tmp.append(" (#")
        tmp.append(s.id.n)
        tmp.append(")")
        
        add_history(tmp.sliced())
        return s.id
    }
    fn rename_snapshot(id: SnapshotID, text: char[]) -> bool {
        snapshot := find_snapshot(id)
        if !snapshot {
            return false
        }
        
        snapshot.description.clear()
        snapshot.description.append(text)
        
        return true
    }
    
    fn add_history(text: char[]) {
        history.add(LogOperation{})
        h := history.get_unsafe(history.size()-1)
        h.content.append(text)
    }
    
    fn track_file(path: char[], lastModified: u64, workspace_file_index: i32 = -1) {
        if workspace_file_index == -1 {
            files.add(WorkspaceFile{})
            workspace_file_index = cast<i32>files.size() - 1
        }
        f := files.get_unsafe(workspace_file_index)
        if f.path.len == 0
            f.path.append(path)
        f.lastModified = lastModified
        f.marked = true
    }
    // fn untrack_file(path: char[], lastModified: u64) {
    //     files.add(WorkspaceFile{})
    //     f := files.get_unsafe(files.size() - 1)
    //     f.path.append(path)
    //     f.lastModified = lastModified
    // }
    
    // returns -1 if not found
    fn find_index_of_branch(id: BranchID) -> i32 {
        found: i32 = -1
        for @ptr branches.sliced_unsafe() {
            if it.id == id {
                found = nr
                break
            }
        }
        return found
    }
    fn find_index_of_branch(name: char[]) -> i32 {
        found: i32 = -1
        for @ptr branches.sliced_unsafe() {
            if equal(it.name.sliced(), name) {
                found = nr
                break
            }
        }
        return found
    }
    fn find_branch(id: BranchID) -> Branch* {
        for @ptr branches.sliced_unsafe() {
            if it.id == id {
                return it
            }
        }
        return null
    }
    fn find_snapshot(id: SnapshotID) -> Snapshot* {
        for @ptr snapshots.sliced_unsafe() {
            if it.id == id {
                return it
            }
        }
        return null
    }
}
struct LogOperation {
    content: StringBuilder;
}
struct Snapshot {
    id: SnapshotID;
    description: StringBuilder;
    
    parent: SnapshotID; // is multiple parents possible
    
    // data, files
    fileChanges: DynamicArray<FileChange>;
}
enum ChangeType : u8 {
    CHANGE_CREATION,
    CHANGE_DELETION,
    CHANGE_MODIFICATION,
}
struct FileChange {
    file: StringBuilder;
    changeType: ChangeType;
    changes: DynamicArray<TextChange>;
}
struct TextChange {
    line_start: i32;
    line_end: i32;
    text: StringBuilder;
}
struct SnapshotID {
    n: u64; // zero is invalid snapshot
}
struct BranchID {
    n: u64; // zero is invalid snapshot
}
operator ==(a: BranchID, b: i32) -> bool {
    return a.n == b
}
operator !=(a: BranchID, b: i32) -> bool {
    return a.n != b
}
operator ==(a: BranchID, b: BranchID) -> bool {
    return a.n == b.n
}
operator !=(a: BranchID, b: BranchID) -> bool {
    return a.n != b.n
}
operator ==(a: SnapshotID, b: SnapshotID) -> bool {
    return a.n == b.n
}
struct Branch {
    id: BranchID;
    name: StringBuilder;
    snapshot: SnapshotID;
}