
// a: i16 = 256* 10 + 13;

// printi(*(&a))
// printi(*(cast<i8*>&a + 1))

struct A {
    a: i64;
}
a = A{9};
p = &a;
// printi(*(&p));
// printi((&p).a);
// printi(p.a);
// printi(a.a);
printi(*((&p.a) + 0));

// #import "Basic"

// struct poly<T> {
//     num: T;
// }

// struct wa {
// // struct wa<P> {
//     a: poly<i32>;
//     // b: poly<P>;
//     b: poly<i64>;
// }

// // w = wa<i64>{ poly<i64>{5} };
// // w = wa<i64>{ poly<i32>{92}, poly<i64*>{null} };
// w = wa{ poly<i32>{123}, poly<i64>{32} };

// enum TIP {
//     One = 0x1,
//     T = 0x4
// }

// printi(cast<i32>TIP.One)
// printi(cast<i32>TIP.T)

// a: i32 = TIP.One;

// a: TIP;
// using TIP as tip;
// b: tip;

// struct O {
//     a: i32
// }
// namespace A {
//     namespace SUP {
//         struct B {
//             a: i32;
//             // b: O
//         }
//     }
// }
// struct P<T> {
//     a: T
// }
// using P<i32> as Num
// // using A::SUP as K
// // b: K::B;
// n = Num{29};
// printi(n.a);
// b: A::B;

// using 

// var = 27;

// using var as var2;

// printi(var2);
// var = 29
// printi(var2);

// struct aa{
//     a: i32;
//     b: i64;
//     c: i32;
// }
// // {
// //     a: u8;
// //     // printi(cast<i64>&a + cast<i64>1);
// // }
// // {
// // a: aa = aa{5,15};
// a: aa = aa{5,15,27};
// //     // printi(cast<i64> &a);
// printi(a.a);
// printi(a.b);
// printi(a.c);
// }
    // fn get() -> i32 {
    //     return this.num;
    // }
// struct Num {
//     n: i32;
// }
// {
//     using Num<T> as Num<R>
//     using T as Num;
// fn add<T>(a: T, b: T) -> T {

//     fn clamp(a: T) -> T{
//         return a + 1
//     }
//     return a + b;
// }

// operator +<T=i32,f32>(){

// }

// }
// a = poly{ext<i32>{5}};
// printi(a.a.t);
// printi(a.add());
// p = &a;
// printi(p.num);
// prints("hello!\n")

// fn printi(n: i32) @native
// fn printi(n: i32) @dll