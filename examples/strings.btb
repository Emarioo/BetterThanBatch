// A = B = 9
// A = B += 9
// a: i32;
// ptr: i32* = &a;
// ptr *= 7

// a = 8 + 1 = 1 ( a |= b )
// printi(b)

// struct Vec<T>{
//     x: T;
//     fn add<T>(a: T) {
//         this.x += a;
//     }
// }
// v = Vec<i32>{2};
// v.add<i32>(1)


struct Vec {
    x: i32;
    fn add<T>(a: T) {
    // fn add(a: i32) {
        // printi(this.x)
        // printi(a)
        this.x += a;
    }
}

v = Vec{3};
// p = &v;
v.add<i32>(2)


printi(v.x)
// v.add(2)
// // v.x += 2;
// // p.m = 9

// a = 9;

// a = 4;

// printi(a);

// *cast<i32*>&a += 3



// printi(v.x)
// printi(v.add<f32>(1.5))
// printi(v.x)

// struct Vec<N>{
//     x: N;
//     // fn add<i32>(a: i32 ) { 
//     fn add(a: i32) { 
//     // fn add(a: i32 ) { 
//         // printi(this.x); 
//         this.x += cast<f32>a+0.5;
//     }
// }
// // fn V_add(this: V*, a: i32) { this.x += a}

// v = V{5};
// // printi(v.x);
// // v.x += 23;
// v.add<f32>(0.5);
// printi(v.x);

// *(&var + 4) = 5
// *(&(*ptr).b + 4) = 5

// *(ptr + 4) = 4

// ad = 32

// p = &((*(ad+4)).eed)

// struct A<T>{
//     fn add(t: T) {
//         printi(t)
//     }
// }

// fn top<T>(){
//     fn low(){
//         a: T;
//     }
// }

// fn ee({
//     return
// }

// a: A;
// a.add(33);

// fn add<T>(a: T, b: T) -> T {
//     sum: T = a + b;
//     sum: i32 = 2;
//     return sum;
// }

// fn addi(a: i32, b: i32) -> i32 { return a + b }

// printi(add<i32>(1.4,2.5))
// printi(addi(1.6,2.5))
// printi(add<f32>(1.6,2.5))
// printi(add<i32>(8,42))

// printi(1.6 + 2.5)

// a: i16 = 256* 10 + 13;
// printi(*(&a))
// printi(*(cast<i8*>&a + 1))

// struct A {
//     a: i64;
// }
// a = A{9};
// p = &a;
// printi(*(&p.a + 0));
// printi(*(&p));
// printi((&p).a);
// printi(p.a);
// printi(a.a);

// #import "Basic"

// struct poly<T> {
//     num: T;
// }

// struct wa {
// // struct wa<P> {
//     a: poly<i32>;
//     // b: poly<P>;
//     b: poly<i64>;
// }

// // w = wa<i64>{ poly<i64>{5} };
// // w = wa<i64>{ poly<i32>{92}, poly<i64*>{null} };
// w = wa{ poly<i32>{123}, poly<i64>{32} };

// enum TIP {
//     One = 0x1,
//     T = 0x4
// }

// printi(cast<i32>TIP.One)
// printi(cast<i32>TIP.T)

// a: i32 = TIP.One;

// a: TIP;
// using TIP as tip;
// b: tip;

// struct O {
//     a: i32
// }
// namespace A {
//     namespace SUP {
//         struct B {
//             a: i32;
//             // b: O
//         }
//     }
// }
// struct P<T> {
//     a: T
// }
// using P<i32> as Num
// // using A::SUP as K
// // b: K::B;
// n = Num{29};
// printi(n.a);
// b: A::B;

// using 

// var = 27;

// using var as var2;

// printi(var2);
// var = 29
// printi(var2);

// struct aa{
//     a: i32;
//     b: i64;
//     c: i32;
// }
// // {
// //     a: u8;
// //     // printi(cast<i64>&a + cast<i64>1);
// // }
// // {
// // a: aa = aa{5,15};
// a: aa = aa{5,15,27};
// //     // printi(cast<i64> &a);
// printi(a.a);
// printi(a.b);
// printi(a.c);
// }
    // fn get() -> i32 {
    //     return this.num;
    // }
// struct Num {
//     n: i32;
// }
// {
//     using Num<T> as Num<R>
//     using T as Num;

    // fn clamp<T>(a: T) -> T{
    //     return a + 1
    // }
// operator +<T=i32,f32>(){

// }

// }
// a = poly{ext<i32>{5}};
// printi(a.a.t);
// printi(a.add());
// p = &a;
// printi(p.num);
// prints("hello!\n")

// fn printi(n: i32) @native
// fn printi(n: i32) @dll