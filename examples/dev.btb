// @macro-benchmark
// #import "OS"
// #import "Basic"
// #import "String"
// #import "Math"

// #import "macros"
// #import "macro-bench"
// #import "overloading"
// #import "defer"
// #import "dir-iterator"
// #import "random/operator"
// #import "threads"
// #import "linecounter"
// #import "graphics/quad.btb"
// #import "graphics/perf.btb"

// #import "Array"
// #import "unix/threads"
// #import "Thread"
// #import "Unix"
#import "Logger"
#import "OS"

// // fn @import @unixcall StartMeasure() -> u64;
// // fn @import @unixcall StopMeasure(timePoint: u64) -> i32; // TODO: Use f64 (double) when implemented
// // fn @import @unixcall StopMeasure(timePoint: u64) -> f32; // TODO: Use f64 (double) when implemented

// #define CLOCK_MONOTONIC 1
// struct timespec {
//     tv_sec: u64;
//     tv_nsec: u32;
// }
// fn @import @unixcall clock_gettime(clk_id: i32, tp: timespec*) -> i32;

// fn @intrinsic rdtsc() -> u64;


// tp: timespec;
// err = clock_gettime(CLOCK_MONOTONIC, &tp);
// #define NS cast<u64>1000000000

fn time() -> u64 {
    return rdtsc();
    // tp: timespec;
    // err = clock_gettime(CLOCK_MONOTONIC, &tp);
    // #define NS cast<u64>1000000000
    // huge: u64 = NS*tp.tv_sec + tp.tv_nsec;
    // return huge;
}
start = time()
NativeSleep(0.01)
end = time() - start;

v: u64[]{
    47627486,
    53253632,
}

t = cast<f64>end/cast<f64>2900000000; ///cast<f32>NS;
log("end",end,"t",t);

// t = cast<f32>end/cast<f32>2900000000; ///cast<f32>NS;
// log("end",end,"t",t);


// ###########################
// make these compile and work
// ###########################
// t = cast<f32>cast<u32>23 == 23.0
// t = cast<f32>cast<u64>23 == 23.0
// log(t);

// fn hey(tf: char) {
//     a = Slice<char>{&tf,1};
// }

// hey(3)

// fn printBits(bits: u32) {
//     for @reverse 0..32 {
//         if bits & (cast<u64>1 << nr) {
//             print('1')
//         } else 
//             print('0')
//     }
//     print('\n')
// }

// printBits(*cast<u64*>cast<void*>&t);

// // fn @unixcall k() -> f32 { return 0.5 }
// // a = k();


// tp = StartMeasure();

// NativeSleep(3.3);

// t = StopMeasure(tp);

// log(t);

// log("dev")

// #import "Map"
// Test_StringMap();

// #define l0(a0) a0
// #define l1(a1) l0(a1)
// #define l2(a2) l1(a2)

// l2(yes)


// #define c 1 2 3 4 5 6

// #import "out" as cool

// cool::hey()
// hey()

// #define l2(a2) l1(a2)

// HELLO, THOUGH BUG HERE FIX IT NOW (preprocessor bug)
// #define l0(a0,...) a0
// #define l1(...) l0(...)

// a l2(9)
// a l1(1,2)

// #define g2(...) g1(...)
// #define g1(X,...) X + g1(...)

// a g1(1,2)
// a g2(1,2)

// for 0..256 {
//     log(it,it & 0xe0, it < 32);
// }

// #define A1 3
// #define A2 3 4
// #define A3 3 4 5

// #define k0(X,...) X.. k0(...)
// a k0(#unwrap A1)

// #define n2(x,...) x - n2(...)

// ##define n(...) [ n1(3) ]
// ##define n1(x) x *
// n(na,na)


// #define log(...) { log_inner(...) }
// #define log_inner(X, ...) log_inner(...)
// #define log_inner(X) p('\n')

// log(a,b)

// #import "Logger"
// #define log(...) { log_inner(...) }
// #define log_inner(X, ...) p(X); p(' '); log_inner(...)
// #define log_inner(X) p(X); p('\n')

// #define println(...) { print_inner(...) _print("\n"); }
// #define print(...) { print_inner(...) }
// #define print_inner(X,...) _print(X); print_inner(...)

// log("StringMap")
// a log("a", "b")
// for elements {
//     print(nr,": ",it);
// }
// log(" baseArray:", baseArray.len);
// for baseArray {
//     print(nr,": ");
// }

// #define base(x,y,F) if(flags & F) { x - y }
// #define log(x,y) base(x,y, LOG_TYPE)
// #define ENTER yoo, hi
// log(ENTER,AND SO I)


// #define k1(...) [ k0(...) ]

// #define k2(a,b) k1(A,a,b,B)


// // #define clear() print("\033[H\033[J")
// UNIX coloring doesn't work
// s = "\x1b";
// print(cast<i32>s.ptr[0])

// print("\x1b[33;1mHello Dude\n")
// print("Hello\n");
// move_cursor(-2,0);
// print("Sup\n");

// fn @unixcall ok() -> f32 {
//     return 0.32
// }
// t = StartMeasure()
// StopMeasure(t)
// v = cast_unsafe<f64> asm { sub rsp, -8; movsd [rsp], xmm0 }
// log(v)

// #import "Logger"

// a: f32 = 324.1245;
// b: f32 = 92.5123;

// c: f64 = 9512.2d;
// d: f64 = 52.92d;


// r0: f32 = a + b
// r1:f32 = c + d
// println(r0)
// println(r1)

// print(5.3d)

// fn ka(v: f32) { }
// fn ka(v: f64) { }

// ka(cast<i32>3);
// ka(cast<i64>5);

// struct ThreadContext {
//     sum: i64;
//     running: bool = false;
//     thread: Thread;
// }
// contexts: ThreadContext[4];

// #define ADD(I) contexts.ptr[I].running=true; contexts.ptr[I].thread = ThreadCreate(ThreadWork, &contexts.ptr[I]);
// ADD(0)
// ADD(1)
// ADD(2)
// ADD(3)
// #undef ADD


// fn print_state(contexts: ThreadContext[], initial: bool = false) {
//     if !initial {
//         move_cursor(0,4);
//     }
//     for 0..4 {
//         print("T",it,": ", contexts.ptr[it].sum,"\n");
//     }
// }

// print_state(contexts, true);

// start_time = StartMeasure()

// i = 0;
// running_any = false;
// while true {
//     if i == 0 {
//         running_any = false;
//         print_state(contexts);
//         NativeSleep(0.1);
//     }
//     if contexts.ptr[i].running {
//         running_any = true;
//     }

//     i = (i + 1) % cast<i32>contexts.len;
//     if i == 0 && !running_any {
//         break;
//     }
// }

// for @ptr contexts {
//     ThreadJoin(it.thread);
// }

// end_time = StopMeasure(start_time);
// log("Time",end_time)

// sum = 0
// for @ptr contexts {
//     sum += cast<i64>it.sum;
// }
// log("Finished sum:", sum, "in", cast<i32>(end_time * 1000),"ms");



// fn @unixcall ThreadWork(param: ThreadContext*) -> void* {
//     for 0..10000000 {
//         param.sum++;
//     }
//     // param.sum += 5;
//     // log("T done: ",param.thread.id);
//     param.running = false;
//     return null;
// }
