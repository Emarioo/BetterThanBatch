// #import "OS"
// #import "Basic"
// #import "String"
// #import "Math"

// #import "macros"
// #import "macro-bench"
// #import "overloading"
// #import "defer"
// #import "dir-iterator"
// #import "random/operator"
// #import "threads"
// #import "linecounter"
// #import "graphics/quad.btb"
// #import "graphics/perf.btb"

// #import "Array"
// #import "unix/threads"
// #import "Thread"
// #import "Unix"
// #import "Logger"
// // #import "OS"

// // fn @import @unixcall StartMeasure() -> u64;
// // fn @import @unixcall StopMeasure(timePoint: u64) -> i32; // TODO: Use f64 (double) when implemented
// // fn @import @unixcall StopMeasure(timePoint: u64) -> f32; // TODO: Use f64 (double) when implemented

// #define CLOCK_MONOTONIC 1
// struct timespec {
//     tv_sec: u64;
//     tv_nsec: u32;
// }
// fn @import @unixcall clock_gettime(clk_id: i32, tp: timespec*) -> i32;

// fn @intrinsic rdtsc() -> u64;


// tp: timespec;
// err = clock_gettime(CLOCK_MONOTONIC, &tp);
// #define NS cast<u64>1000000000

// fn time() -> u64 {
//     return rdtsc();
//     // tp: timespec;
//     // err = clock_gettime(CLOCK_MONOTONIC, &tp);
//     // #define NS cast<u64>1000000000
//     // huge: u64 = NS*tp.tv_sec + tp.tv_nsec;
//     // return huge;
// }
// start = time()
// NativeSleep(0.01)
// end = time() - start;

// HELLO! NEXT STEP, fix profiling of time
// StartMeasure/StopMeasure didn't work before, do they now?

// #import "examples/binary_viewer/main.btb"
#import "bug.btb"


// a := 9

// fn many() -> i32, i32 { return 0, 3 }
// a, b := many()

// #import "Logger"

// hi := 9

// log(hi);

// fn @okay(a: i32) {


// }

// a := 0

// if 1 {
//     a = 9
// }

// switch a {
//     case 0:
//         a = 1
//     case:
//         a = -1
// }

// a

// #import "OS"
// #import "Logger"

// ptr = Allocate(16)
// newPtr = Reallocate(ptr, 16, 17);

// log(cast<u64>ptr, cast<u64>newPtr)

// #import "OS"
// #import "Logger"

// #import "Array"

// arr: DynamicArray<i32>;
// arr.add(4)
