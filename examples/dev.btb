// #import "examples/crawler/main" // With hotreloading
// #import "examples/crawler/GameCore" // Without hotreloading

/*  
    Today's quest: Hardware/software exceptions

    Stuff to consider when implementing exceptions:
        Windows and Linux does it differently.
        On Windows we need to:
            Create three additional sections (.xdata, .pdata, .text$x)
            Fill them with function entries, unwind info? code of exception handlers.
        On Linux we need to:
            Emit function call to sigaction before "try", and fill the sigaction data structure that is passed, also store previous sigaction structure.
            Emit function call to sigaction at the end of try to
*/

#import "Windows"
#import "Logger"

enum ExceptionType {
    EXCEPTION_MEMORY,
    EXCEPTION_ZERO_DIVISION,
}

try {
    *cast<i32*>cast<i64>0 = 9
} catch EXCEPTION_MEMORY {
    prints("caught\n")
}
prints("done\n")


fn @export @oscall exception_handler(record: EXCEPTION_RECORD*, establisherFrame: u64, context: CONTEXT*, dispatcherContext: DISPATCHER_CONTEXT*) -> EXCEPTION_DISPOSITION {
    prints("hit\n")

    context.Rip += 2 + 5 // catch block, hopefully

    RtlRestoreContext(context, null)

    prints("Late\n") // does not get called because RtlRestoreContext doesn't return, after all, it modifies the thread context and changes the instruction pointer.

    return EXCEPTION_DISPOSITION.ExceptionContinueExecution
}

// fn @export @oscall exception_filter() -> i32 {

// }