// @macro-benchmark
// #import "OS"
// #import "Logger"
// #import "Basic"
// #import "String"
// #import "Math"

// #import "macros"
// #import "macro-bench"
// #import "overloading"
// #import "defer"
// #import "dir-iterator"
// #import "random/operator"
// #import "threads"
// #import "linecounter"
// #import "graphics/quad.btb"
#import "graphics/perf.btb"
// #import "a"
// #import "b"

// a: u64 = 9;

// if 1 {
//     @dump-bc
// // @dump-asm
//     a = 0x1000_0000_0000_0000;
//     a + 2
// }

// log(intPart)
// buffer: char[200];
// // buffer += 
// swrite_unsafe(buffer.ptr, 29);

// #import "OS"

// // Returns the amount of written bytes
// // Will put a null termination at the end of the written bytes
// fn @hide swrite_unsafe(buffer: char*, value: i64) -> u32 {
//     start = buffer;
//     if value == 0 {
//         buffer[0] = '0';
//         buffer[1] = '\0';
//         return 1;
//     }
//     if value < 0 {
//         value = -value;
//         *buffer = '-';
//         buffer++;
//     }
//     str: char[21];
//     used = 20;
//     while value > 0 && used > 0 {
//         num = value % 10;
//         value = value / 10;
//         str.ptr[used] = num + '0';
//         used--;
//     }
//     str.ptr += used + 1;
//     str.len -= used + 1;

//     memcpy(buffer, str.ptr, str.len);
//     buffer += str.len;
//     *buffer = '\0'; // not include in written bytes

//     return cast<u64>(buffer - start);
// }
// ptr: char[100];
// hz = 2900_000_000;
// a = 174135859434487;
// a = 0;
// b = 174135928898094;
// c = 174135928898094 - 174135859434487;
// log(c);

// time = 1000.0 * cast<f32>(b - a) / hz;
// time = 
// 1000.0 * 
// cast<f32>(c) / hz;
// cast<f32>(69463607) / 
// cast<f32> 2900_000_000;
// sizeof hz
// cast<f32> 2900_000_000;
// cast<f32>(0x8000_0000_0000_0001);
// cast<f32>cast<u64>(0x4000_0000_0000_0013);
// x = cast<f32>(0x0011);
// x = 
// cast<f32>cast<u64>(0x8000_0000_0000_0013);
// log(999999999.0)
// log(x);

// fn fun() -> i32 {
//     return 8
// }
// f = fun();
// fn @native printc(chr: char);

// #define LN printc('L'); printc('N');
//  _print(#line); _print('\n')

// LM
// printc('L'); printc('N');

// fn @native prints(str: char[]);
// fn @native printc(str: char);

// a: f32 = 434278354027236 - 434278267340793;
// a: f32 = 86686.0;
// a: f32 = 86686440.0;
// a
// log(a);

// a: u64 = 923

// a < 0u
// log(-32)

// 38 % 10
// t = -23
// log("int")
// signed = false;
// if t < 0 {
//     signed = true;
//     t = 0-t;
// }
// t

// -23 < 0

// str: char[20];
// used = 19;
// while t > 0 && used > 0 {
//     num = t % 10;
//     // log('A','0'+num)
//     // log(,num)
//     str.ptr[used] = num + '0';
//     used--;
    
//     t = t / 10;
// }
// str.ptr += used + 1;
// // str.len -= used - 1;
// str.len -= used - 1;
// if signed
//     printc('-');
// prints(str);
// t = 9

// 1 && 0

// signed = false;
// if t < 0 {
//     signed = true;
//     t = 0-t;
// }
// str: char[20];
// used = 2;
// // while t > 0 && used > 0 {
// while 
// // t > 0 
// 0 &&
//  used > 0 {
//     // num = t % 10;
//     // str.ptr[used] = num + '0';
//     used--;
//     // printc('a');
//     // t = t / 10;
// }
// str.ptr += used + 1;
// str.len -= used - 1;
// str.len -= used + 1;
// if signed
//     printc('-');
// prints(str);

// ptr: ProfiledData* = Allocate(sizeof ProfiledData);
// memzero(ptr, sizeof ProfiledData);
// path = "garb.txt"
// file = FileOpen(&path, true, &fileSize);
// if(!file)
//     return null;
// data: void* = 
// Allocate(0);
// FileRead(file, data, fileSize);
// FileClose(file);

// offset = 0;

// ptr.contextCount = *cast<u32*>data + offset;

// a: i32 = 24.23
// a = 24.23 + 24.23
// 0x1000_0000_0000_0000 > 0
// 0x8000_0000_0000_0000 > 0
// 0x0000_0001_0000_0000 > 0
// 0x0000_0000_8000_0000 > 0

// push        rbp
// mov         rbp,rsp
// asm {
//     mov         rax,100000000h

//     push        rax
//     xor         rcx,rcx
//     pop         rax
//     movsxd      rax,eax
//     cmp         rax,rcx
//     seta        cl
//     // movzx       ecx,cl
//     // and         ecx,0FFFFFFFFh
//     push        rcx
//     // xor         rax,rax
//     pop         rax
// }
// pop         rbp
// ret

// 213123 > 0

// above -> 1
// signed > unsigned
// -10 > 200

// !CF && !ZF

// CF (below/above)
// 0 AE
// 1 B

// SF != OF (less/greater)
// 00 GE
// 01 L
// 10 L
// 11 GE

// 128 > 0
// -128 - 0


// signed > unsigned
// -128  >  255 0
// 128 > 255 0
// -128 > -1 0

// -10  > 200 0

// -1 >= 255 0

// 255 255

// signed > signed L/G
// unsigned > unsigned: A/B

// unsigned < signed



// unsigned > signed // A/B
// pos > neg
// posH > posL
// posL > posH
// pos > pos (equal)
// pos > new (equal)

// signed > unsigned // L/G
// pos > neg
// posH > posL
// posL > posH
// pos > pos (equal)
// pos > new (equal)

// SF != OF (less/greater)
// 00 GE
// 01 L
// 10 L
// 11 GE



// unsigned - signed
// u64 > u64

// u64 - u64 > 0


// signed > unsigned

// signed < 1 = 0


// sub signed, unsigned

// -100 - 1
// -101
// -1
// 5 - 1
// 4
// 2
// 1 + 1
// 0


// if sign bit (negative result)
//     less
// else
//     greater





// CF = 1
// OF = 

// -128 > 0
// (255 > 0)

// cmp 0, 0x80

// jae, CF = 0


// 255 > -1
// (255 > 255)

// -1 > -1
// (255 > 255)

// -1 > 250
// (255 > 250)

// u64 - s64

// cast<f32>(c) / cast<f32>hz;
// log(time);
// len = swrite_unsafe(ptr.ptr, time);
// ptr.len = len;
// log(99999999999.0)
// _print(9999999999.0)
//    aaa(9999999999.0)

// t = 9999999999.0
// t = 23232.0
// bits: u32 = *cast<u32*>cast<void*>&t;
// exp = (bits >> 23) & 0xFF
// mantissa: u64 = 0x80_0000 | (bits & 0x7FFFFF)

// intPart: u64 = 0;
// decimalBits: i32 = 23 - (exp-127);

// intPart = 10000000000
// intPart = 0
// (mantissa) << (0-decimalBits);

// t: f32 = 0;
// t == 0;