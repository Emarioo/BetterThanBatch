// #import "examples/crawler/main" // With hotreloading
// #import "examples/crawler/GameCore" // Without hotreloading

/*  
    Today's quest: Hardware/software exceptions

    Stuff to consider when implementing exceptions:
        Windows and Linux does it differently.
        On Windows we need to:
            Create three additional sections (.xdata, .pdata, .text$x)
            Fill them with function entries, unwind info? code of exception handlers.
        On Linux we need to:
            Emit function call to sigaction before "try", and fill the sigaction data structure that is passed, also store previous sigaction structure.
            Emit function call to sigaction at the end of try to


    nocheckin TODO: 
        Catch crash from function call
        Restore stack before catch
        Handle catch expression filter
        Add exception information inside catch blow, either implicit variable or something like 'catch except_var : EXCEPTION_MEMORY {'
*/

#import "Exception"
#import "Logger"

/*
    Case 1: Crash directly inside try-block
*/
try {
    *cast<i32*>cast<i64>0 = 9
} catch EXCEPTION_MEMORY {
    prints("caught\n")
}

/*
    Case 2: Crash from function
*/
// fn crash() {
//     *cast<i32*>cast<i64>0 = 9
// }
// try {
//     crash()
// } catch EXCEPTION_MEMORY {
//     prints("caught\n")
// }

/*
    Case 3: Restoration of stack pointer.
*/
// x: i32 = 5
// try {
//     y: i32 = 2
//     *cast<i32*>cast<i64>0 = 9
// } catch EXCEPTION_MEMORY {
//     prints("caught outer\n")
// }
// log("x: ",x)
// If stack is messed up then when 'ret' should pop the wrong value from stack (not the return address) and crash.

/*
    Case 4: Fixing of stack pointer if crash comes from function
*/
// TODO: