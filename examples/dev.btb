// @macro-benchmark
// #import "OS"
// #import "Basic"
// #import "String"
// #import "Math"

// #import "macros"
// #import "macro-bench"
// #import "overloading"
// #import "defer"
// #import "dir-iterator"
// #import "random/operator"
// #import "threads"
// #import "linecounter"
// #import "graphics/quad.btb"
// #import "graphics/perf.btb"

// #import "Array"

#import "Thread"
#import "OS"
// #import "Logger"
#import "Unix"

// #import "Map"
// Test_StringMap();

// #define l0(a0) a0
// #define l1(a1) l0(a1)
// #define l2(a2) l1(a2)

// l2(yes)


// #define c 1 2 3 4 5 6

// #import "out" as cool

// cool::hey()
// hey()

// #define l2(a2) l1(a2)

// HELLO, THOUGH BUG HERE FIX IT NOW (preprocessor bug)
// #define l0(a0,...) a0
// #define l1(...) l0(...)

// a l2(9)
// a l1(1,2)

// #define g2(...) g1(...)
// #define g1(X,...) X + g1(...)

// a g1(1,2)
// a g2(1,2)

// for 0..256 {
//     log(it,it & 0xe0, it < 32);
// }

// #define A1 3
// #define A2 3 4
// #define A3 3 4 5

// #define k0(X,...) X.. k0(...)
// a k0(#unwrap A1)

// #define n2(x,...) x - n2(...)

// ##define n(...) [ n1(3) ]
// ##define n1(x) x *
// n(na,na)


// #define log(...) { log_inner(...) }
// #define log_inner(X, ...) log_inner(...)
// #define log_inner(X) p('\n')

// log(a,b)

// #import "Logger"
// #define log(...) { log_inner(...) }
// #define log_inner(X, ...) p(X); p(' '); log_inner(...)
// #define log_inner(X) p(X); p('\n')

// #define println(...) { print_inner(...) _print("\n"); }
// #define print(...) { print_inner(...) }
// #define print_inner(X,...) _print(X); print_inner(...)

// log("StringMap")
// a log("a", "b")
// for elements {
//     print(nr,": ",it);
// }
// log(" baseArray:", baseArray.len);
// for baseArray {
//     print(nr,": ");
// }

// #define base(x,y,F) if(flags & F) { x - y }
// #define log(x,y) base(x,y, LOG_TYPE)
// #define ENTER yoo, hi
// log(ENTER,AND SO I)


// #define k1(...) [ k0(...) ]

// #define k2(a,b) k1(A,a,b,B)


// // #define clear() print("\033[H\033[J")
// UNIX coloring doesn't work
// s = "\x1b";
// print(cast<i32>s.ptr[0])

// print("\x1b[33;1mHello Dude\n")
// print("Hello\n");
// move_cursor(-2,0);
// print("Sup\n");

// fn @unixcall ok() -> f32 {
//     return 0.32
// }
t = StartMeasure()
StopMeasure(t)
v = cast_unsafe<f64> asm { sub rsp, -8; movsd [rsp], xmm0 }
log(v)

// struct ThreadContext {
//     sum: i64;
//     running: bool = false;
//     thread: Thread;
// }
// contexts: ThreadContext[4];

// #define ADD(I) contexts.ptr[I].running=true; contexts.ptr[I].thread = ThreadCreate(ThreadWork, &contexts.ptr[I]);
// ADD(0)
// ADD(1)
// ADD(2)
// ADD(3)
// #undef ADD


// fn print_state(contexts: ThreadContext[], initial: bool = false) {
//     if !initial {
//         move_cursor(0,4);
//     }
//     for 0..4 {
//         print("T",it,": ", contexts.ptr[it].sum,"\n");
//     }
// }

// print_state(contexts, true);

// start_time = StartMeasure()

// i = 0;
// running_any = false;
// while true {
//     if i == 0 {
//         running_any = false;
//         print_state(contexts);
//         NativeSleep(0.1);
//     }
//     if contexts.ptr[i].running {
//         running_any = true;
//     }

//     i = (i + 1) % cast<i32>contexts.len;
//     if i == 0 && !running_any {
//         break;
//     }
// }

// for @ptr contexts {
//     ThreadJoin(it.thread);
// }

// end_time = StopMeasure(start_time);
// log("Time",end_time)

// sum = 0
// for @ptr contexts {
//     sum += cast<i64>it.sum;
// }
// log("Finished sum:", sum, "in", cast<i32>(end_time * 1000),"ms");



// fn @unixcall ThreadWork(param: ThreadContext*) -> void* {
//     for 0..10000000 {
//         param.sum++;
//     }
//     // param.sum += 5;
//     // log("T done: ",param.thread.id);
//     param.running = false;
//     return null;
// }
