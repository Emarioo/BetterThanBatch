
// #import "examples/crawler/main"
// #import "examples/crawler/GameCore"

/* Today's quest: Hotreloading

    A standard library (module) for hotreloading.
    Hotreloading may require custom allocators.
    We may need the ability to change allocators of
    arrays and maps.
    
    Step 0:
        Compile and use dlls

    Step 1:    <- I am here
        Get hotreloading working with crawler game.
        Generalize hotreloading into a module.
        Test it however we would do that?

    Step 2 (maybe later, add to TODO list):
        Module for reloading files and settings with file watchers.
        For example: If an image is modified, it's automatically reloaded.

    Step 3 (maybe later, add to TODO list):
        A compiler feature that warns you when a struct is modified if
        the game is running and you are using hotreloading.

    What is hotreloading?
        It's about changing the game code while the game is running.
        The state and memory used by the game stays the same.
        This means that changing structs will break things since the 
        stored memory is based on the old structs while the new code 
        is based on the new structs.

        Hotreloading is implemented using dynamic libraries (dll, so) and
        a separation between code and state in the game.
        
*/

// TODO: Fix double precision float to string conversion

#import "Logger"
v: f64;
*cast_unsafe<i64*>&v = 0x41A2DDFC0884C4A9

log(v)

// btb examples/dev -o bin/core.dll
// btb examples/dev -o main.exe -r

// #if BUILD_DLL

// #import "GLAD"
// #import "GLFW"

// fn @export init() -> void* {
//     glfwInit();
//     win := glfwCreateWindow(800,600,"title".ptr,null,null);
//     glfwMakeContextCurrent(win);

//     gladLoadGL()
//     func := glViewport
//     return func
// }
// fn @export get_func() -> void* {
//     func := glViewport
//     return func
// }

// #else
// #import "OS"
// #import "Logger"
// fn main() {
//     lib := LoadDynamicLibrary("bin/core.dll")

//     {    
//         f := cast_unsafe< fn @oscall ()->void*> lib.get_pointer("init")
//         ptr := f()
//         log("ptr ",ptr)
//     }

//     // glad_lib := LoadDynamicLibrary("glad.dll")
//     // glfw_lib := LoadDynamicLibrary("glfw3.dll")
//     glad_lib := LoadDynamicLibrary("libs/glad/lib-mingw-w64/glad.dll")
//     glfw_lib := LoadDynamicLibrary("libs/glfw-3.3.9/lib-mingw-w64/glfw3.dll")

//     lib.cleanup()

//     lib = LoadDynamicLibrary("core.dll")

//     {
//         f := cast_unsafe< fn @oscall ()->void*> lib.get_pointer("get_func")
//         ptr := f()
//         log("ptr ",ptr)
//     }

// }

// #endif
